commit 5e0fe02da42f4fc192e118b0c53c239a28c7643c
Author: Kimi Arvin <missvaltiel@yahoo.com>
Date:   Mon Jan 26 11:09:50 2026 -0800

    Made changes to ensure working with Swift 6 and latest toolchain

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index e3e7dbf..0e7b6bf 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -2,6 +2,9 @@ import Atomics
 import DiscordHTTP
 import DiscordModels
 import Foundation
+#if canImport(FoundationNetworking)
+import FoundationNetworking
+#endif
 import Logging
 import NIOCore
 
@@ -674,7 +677,7 @@ extension BotGatewayManager {
             let description: String
             switch code {
             case let .unknown(codeNumber):
-                switch GatewayCloseCode(rawValue: codeNumber) {
+                switch GatewayCloseCode(rawValue: UInt16(codeNumber)) {
                 case let .some(discordCode):
                     description = "\(discordCode)"
                 case .none:
@@ -690,7 +693,7 @@ extension BotGatewayManager {
     private nonisolated func canTryReconnect(code: URLSessionWSCloseCode?) -> Bool {
         switch code {
         case let .unknown(codeNumber):
-            guard let discordCode = GatewayCloseCode(rawValue: codeNumber) else { return true }
+            guard let discordCode = GatewayCloseCode(rawValue: UInt16(codeNumber)) else { return true }
             return discordCode.canTryReconnect
         default: return true
         }

commit 9a7286fa4b0fe407aa6596a4dc7f108792605d87
Author: Kimi Arvin <missvaltiel@yahoo.com>
Date:   Sun Jan 25 01:24:54 2026 -0800

    Add Windows platform support with zlib compression

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 4d151f9..e3e7dbf 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -3,11 +3,7 @@ import DiscordHTTP
 import DiscordModels
 import Foundation
 import Logging
-import NIO
-import WSClient
-
-import enum NIOWebSocket.WebSocketErrorCode
-import struct NIOWebSocket.WebSocketOpcode
+import NIOCore
 
 public actor BotGatewayManager: GatewayManager {
 
@@ -27,13 +23,13 @@ public actor BotGatewayManager: GatewayManager {
 
     private struct Message {
         let payload: Gateway.Event
-        let opcode: WebSocketOpcode?
+        let opcode: URLSessionWSOpcode?
         let connectionId: UInt?
         var tryCount: Int
 
         init(
             payload: Gateway.Event,
-            opcode: WebSocketOpcode? = nil,
+            opcode: URLSessionWSOpcode? = nil,
             connectionId: UInt? = nil,
             tryCount: Int = 0
         ) {
@@ -44,7 +40,8 @@ public actor BotGatewayManager: GatewayManager {
         }
     }
 
-    var outboundWriter: WebSocketOutboundWriter?
+    var outboundWriter: URLSessionWSOutboundWriter?
+    var webSocketTask: URLSessionWebSocketTask?
     let eventLoopGroup: any EventLoopGroup
     /// A client to send requests to Discord.
     public nonisolated let client: any DiscordClient
@@ -291,21 +288,6 @@ public actor BotGatewayManager: GatewayManager {
             ("compress", "zlib-stream"),
         ]
 
-        let decompressorWSExtension: ZlibDecompressorWSExtension
-        do {
-            decompressorWSExtension = try ZlibDecompressorWSExtension(logger: self.logger)
-        } catch {
-            self.logger.critical(
-                "Will not connect because can't create a decompressor. Something is wrong. Please report this failure at https://github.com/DiscordBM/DiscordBM/issues",
-                metadata: ["error": .string(String(reflecting: error))]
-            )
-            return
-        }
-
-        let configuration = WebSocketClientConfiguration(
-            maxFrameSize: self.maxFrameSize,
-            extensions: [.nonNegotiatedExtension { decompressorWSExtension }]
-        )
         logger.trace("Will try to connect to Discord through web-socket")
         let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
         /// FIXME: remove this `Task` in a future major version.
@@ -313,22 +295,22 @@ public actor BotGatewayManager: GatewayManager {
         /// But for proper structured concurrency, this method should never exit (optimally).
         Task {
             do {
-                let closeFrame = try await WebSocketClient.connect(
+                let (inbound, outbound, task, _) = try await URLSessionWSClient.connect(
                     url: gatewayURL + queries.makeForURLQuery(),
-                    configuration: configuration,
-                    eventLoopGroup: self.eventLoopGroup,
+                    useCompression: true,
                     logger: self.logger
-                ) { inbound, outbound, context in
-                    await self.setupOutboundWriter(outbound)
+                )
 
-                    self.logger.debug("Connected to Discord through web-socket. Will configure")
-                    self.state.store(.configured, ordering: .relaxed)
+                await self.setupOutboundWriter(outbound, task: task)
 
-                    for try await message in inbound.messages(maxSize: self.maxFrameSize) {
-                        await self.processBinaryData(message, forConnectionWithId: connectionId)
-                    }
+                self.logger.debug("Connected to Discord through web-socket. Will configure")
+                self.state.store(.configured, ordering: .relaxed)
+
+                for try await message in inbound {
+                    await self.processBinaryData(message, forConnectionWithId: connectionId)
                 }
 
+                let closeFrame = task.currentCloseFrame
                 logger.debug(
                     "web-socket connection closed",
                     metadata: [
@@ -552,11 +534,10 @@ extension BotGatewayManager {
                 )
             )
         )
-        let opcode = Gateway.Opcode.identify
         self.send(
             message: .init(
                 payload: resume,
-                opcode: .init(encodedWebSocketOpcode: opcode.rawValue)!
+                opcode: .text
             )
         )
 
@@ -578,7 +559,7 @@ extension BotGatewayManager {
     }
 
     private func processBinaryData(
-        _ message: WebSocketMessage,
+        _ message: URLSessionWSMessage,
         forConnectionWithId connectionId: UInt
     ) {
         guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
@@ -633,7 +614,7 @@ extension BotGatewayManager {
     }
 
     private enum CloseReason {
-        case closeFrame(WebSocketCloseFrame?)
+        case closeFrame(URLSessionWSCloseFrame?)
         case error(any Error)
     }
 
@@ -681,7 +662,7 @@ extension BotGatewayManager {
 
     private nonisolated func getCloseCodeAndDescription(
         of closeReason: CloseReason
-    ) -> (WebSocketErrorCode?, String) {
+    ) -> (URLSessionWSCloseCode?, String) {
         switch closeReason {
         case .error(let error):
             return (nil, String(reflecting: error))
@@ -706,7 +687,7 @@ extension BotGatewayManager {
         }
     }
 
-    private nonisolated func canTryReconnect(code: WebSocketErrorCode?) -> Bool {
+    private nonisolated func canTryReconnect(code: URLSessionWSCloseCode?) -> Bool {
         switch code {
         case let .unknown(codeNumber):
             guard let discordCode = GatewayCloseCode(rawValue: codeNumber) else { return true }
@@ -815,7 +796,7 @@ extension BotGatewayManager {
             }
             Task {
                 // If the message has no specified opcode, default to sending .text
-                let opcode: WebSocketOpcode = message.opcode ?? .text
+                let opcode: URLSessionWSOpcode = message.opcode ?? .text
 
                 let data: Data
                 do {
@@ -825,7 +806,7 @@ extension BotGatewayManager {
                         "Could not encode payload",
                         metadata: [
                             "payload": .string("\(message.payload)"),
-                            "opcode": .stringConvertible(opcode),
+                            "opcode": .stringConvertible(opcode.rawValue),
                             "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed)),
                         ]
                     )
@@ -844,33 +825,27 @@ extension BotGatewayManager {
                             "Will send a payload",
                             metadata: [
                                 "payload": .string("\(message.payload)"),
-                                "opcode": .stringConvertible(opcode),
+                                "opcode": .stringConvertible(opcode.rawValue),
                             ]
                         )
                         try await outboundWriter.write(
                             .custom(
-                                .init(
-                                    fin: true,
-                                    opcode: opcode,
-                                    data: ByteBuffer(data: data)
-                                )
+                                fin: true,
+                                opcode: opcode,
+                                data: ByteBuffer(data: data)
                             )
                         )
                     } catch {
-                        if let channelError = error as? ChannelError,
-                            case .ioOnClosedChannel = channelError
-                        {
+                        if case URLSessionWSError.connectionClosed = error {
                             self.logger.error(
-                                "Received 'ChannelError.ioOnClosedChannel' error while sending payload through web-socket. Will fully disconnect and reconnect again"
+                                "Connection closed error while sending payload through web-socket. Will fully disconnect and reconnect again"
                             )
                             await self.disconnect()
                             await self.connect()
-                        } else if message.payload.opcode == .heartbeat,
-                            let writerError = error as? NIOAsyncWriterError,
-                            writerError == .alreadyFinished()
-                        {
+                        } else if message.payload.opcode == .heartbeat {
                             self.logger.debug(
-                                "Received 'NIOAsyncWriterError.alreadyFinished' error while sending heartbeat through web-socket. Will ignore"
+                                "Error while sending heartbeat through web-socket. Will ignore",
+                                metadata: ["error": .string(String(reflecting: error))]
                             )
                         } else {
                             self.logger.error(
@@ -878,7 +853,7 @@ extension BotGatewayManager {
                                 metadata: [
                                     "error": .string(String(reflecting: error)),
                                     "payload": .string("\(message.payload)"),
-                                    "opcode": .stringConvertible(opcode),
+                                    "opcode": .stringConvertible(opcode.rawValue),
                                     "state": .stringConvertible(self.state.load(ordering: .relaxed)),
                                     "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed)),
                                 ]
@@ -931,8 +906,9 @@ extension BotGatewayManager {
         }
     }
 
-    func setupOutboundWriter(_ outboundWriter: WebSocketOutboundWriter) {
+    func setupOutboundWriter(_ outboundWriter: URLSessionWSOutboundWriter, task: URLSessionWebSocketTask) {
         self.outboundWriter = outboundWriter
+        self.webSocketTask = task
     }
 
     private func closeWebSocket() async {
@@ -948,6 +924,7 @@ extension BotGatewayManager {
             )
         }
         self.outboundWriter = nil
+        self.webSocketTask = nil
     }
 }
 

commit 9c427d03a058e4a8880524dcdbad6b033a652469
Author: Kimi Arvin <missvaltiel@yahoo.com>
Date:   Fri Jan 23 15:27:06 2026 -0800

    Replace AsyncHTTPClient with URLSession for cross-platform TLS support
    
    Removes swift-nio-ssl/BoringSSL dependency which has Windows header conflicts.
    URLSession uses native TLS on each platform (SecureTransport, Schannel, OpenSSL).
    
    - Add HTTPExecutor protocol with URLSessionHTTPExecutor implementation
    - Update DefaultDiscordClient to use HTTPExecutor pattern
    - Remove AsyncHTTPClient from Package.swift dependencies
    - Update gateway managers and integration tests

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index efd5a48..4d151f9 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -1,5 +1,5 @@
-import AsyncHTTPClient
 import Atomics
+import DiscordHTTP
 import DiscordModels
 import Foundation
 import Logging
@@ -176,14 +176,14 @@ public actor BotGatewayManager: GatewayManager {
 
     /// - Parameters:
     ///   - eventLoopGroup: An `EventLoopGroup`.
-    ///   - httpClient: A `HTTPClient`.
+    ///   - executor: An ``HTTPExecutor`` for making HTTP requests.
     ///   - clientConfiguration: Configuration of the `DiscordClient`.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
     ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
-        eventLoopGroup: any EventLoopGroup = HTTPClient.shared.eventLoopGroup,
-        httpClient: HTTPClient = .shared,
+        eventLoopGroup: any EventLoopGroup,
+        executor: any HTTPExecutor = HTTPExecutorFactory.createDefault(),
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int = 1 << 28,
         appId: ApplicationSnowflake? = nil,
@@ -191,7 +191,7 @@ public actor BotGatewayManager: GatewayManager {
     ) async {
         self.eventLoopGroup = eventLoopGroup
         self.client = await DefaultDiscordClient(
-            httpClient: httpClient,
+            executor: executor,
             token: identifyPayload.token,
             appId: appId,
             configuration: clientConfiguration
@@ -216,7 +216,7 @@ public actor BotGatewayManager: GatewayManager {
 
     /// - Parameters:
     ///   - eventLoopGroup: An `EventLoopGroup`.
-    ///   - httpClient: A `HTTPClient`.
+    ///   - executor: An ``HTTPExecutor`` for making HTTP requests.
     ///   - clientConfiguration: Configuration of the `DiscordClient`.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
     ///   - token: Your Discord bot-token.
@@ -226,8 +226,8 @@ public actor BotGatewayManager: GatewayManager {
     ///   - presence: The initial presence of the bot.
     ///   - intents: The Discord intents you want to receive messages for.
     public init(
-        eventLoopGroup: any EventLoopGroup = HTTPClient.shared.eventLoopGroup,
-        httpClient: HTTPClient = .shared,
+        eventLoopGroup: any EventLoopGroup,
+        executor: any HTTPExecutor = HTTPExecutorFactory.createDefault(),
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int = 1 << 28,
         token: String,
@@ -239,7 +239,7 @@ public actor BotGatewayManager: GatewayManager {
         let token = Secret(token)
         self.eventLoopGroup = eventLoopGroup
         self.client = await DefaultDiscordClient(
-            httpClient: httpClient,
+            executor: executor,
             token: token,
             appId: appId,
             configuration: clientConfiguration

commit f73c8b34c1360794c71ba77cecb2632041a89b03
Author: Lakhan Lothiyi <42747613+llsc12@users.noreply.github.com>
Date:   Tue Dec 2 11:56:09 2025 +0000

    Fix possible bug with opcode fallback (#96)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index dd9444a..efd5a48 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -814,10 +814,8 @@ extension BotGatewayManager {
                 return
             }
             Task {
-                let opcode: WebSocketOpcode =
-                    message.opcode ?? .init(
-                        encodedWebSocketOpcode: message.payload.opcode.rawValue
-                    )!
+                // If the message has no specified opcode, default to sending .text
+                let opcode: WebSocketOpcode = message.opcode ?? .text
 
                 let data: Data
                 do {

commit c641e8479544beed928ca5cb8baa6dde4d75b1d6
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon Feb 10 23:36:57 2025 +0330

    Set up vscode + use swift-format + other refinements (#86)
    
    * add swift-format + other minor refinements
    
    * add sourcekit-lsp config
    
    * fix unstable enum macro
    
    * require explicit sendable and some more stuff in CI
    
    * use more @SPI
    
    * lint
    
    * fix a warning
    
    * Revert "use more @SPI"
    
    This reverts commit 082a6d963b46304a6c462d9c26e1161b33e2cb7d.
    
    * try fix ci flags
    
    * fix ci flags
    
    * fix failing tests
    
    * try fix a test
    
    * refinements
    
    * try
    
    * minor fixes
    
    * try
    
    * lint

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 9fd2773..dd9444a 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -1,17 +1,18 @@
-import WSClient
-import Foundation
 import AsyncHTTPClient
 import Atomics
-import Logging
 import DiscordModels
+import Foundation
+import Logging
 import NIO
-import struct NIOWebSocket.WebSocketOpcode
+import WSClient
+
 import enum NIOWebSocket.WebSocketErrorCode
+import struct NIOWebSocket.WebSocketOpcode
 
 public actor BotGatewayManager: GatewayManager {
 
     /// The info related to the shard status of this gateway-manager.
-    struct ShardInfo: Sendable {
+    struct ShardInfo {
         var shardConnectedOnceBefore = false
         let shard: IntPair
         let maxConcurrency: Int
@@ -54,7 +55,7 @@ public actor BotGatewayManager: GatewayManager {
     /// This gateway manager's identifier.
     public nonisolated let id = idGenerator.wrappingIncrementThenLoad(ordering: .relaxed)
     let logger: Logger
-    
+
     //MARK: Event streams
     var eventsStreamContinuations = [AsyncStream<Gateway.Event>.Continuation]()
     var eventsParseFailureContinuations = [AsyncStream<(any Error, ByteBuffer)>.Continuation]()
@@ -78,35 +79,35 @@ public actor BotGatewayManager: GatewayManager {
 
     //MARK: Connection data
     public nonisolated let identifyPayload: Gateway.Identify
-    
+
     //MARK: Connection state
     private nonisolated let state = ManagedAtomic(GatewayState.noConnection)
-    
+
     //MARK: Send queue
-    
+
     /// 120 per 60 seconds (1 every 500ms),
     /// per https://discord.com/developers/docs/topics/gateway#rate-limiting
     let sendQueue = SerialQueue(waitTime: .milliseconds(500))
 
     //MARK: Current connection properties
-    
+
     /// An ID to keep track of connection changes.
     nonisolated let connectionId = ManagedAtomic(UInt(0))
-    
+
     //MARK: Resume-related current-connection properties
-    
+
     /// The sequence number for the payloads sent to us.
     var sequenceNumber: Int? = nil
     /// The ID of the current Discord-related session.
     var sessionId: String? = nil
     /// Gateway URL for resuming the connection, so we don't need to make an api call.
     var resumeGatewayURL: String? = nil
-    
+
     //MARK: Shard-ing
     var shardInfo: ShardInfo? = nil
-    
+
     //MARK: Backoff
-    
+
     /// Discord cares about the identify payload for rate-limiting and if you send
     /// more than 1000 identifies in a day, Discord will revoke your bot token
     /// (unless your bot is big enough that has a bigger identify-limit than 1000 per day).
@@ -120,7 +121,7 @@ public actor BotGatewayManager: GatewayManager {
         coefficient: 1,
         minBackoff: 15
     )
-    
+
     //MARK: Ping-pong tracking properties
     var unsuccessfulPingsCount = 0
     var lastPongDate = Date()
@@ -165,12 +166,14 @@ public actor BotGatewayManager: GatewayManager {
             var identifyPayload = identifyPayload
             identifyPayload.shard = nil
             self.identifyPayload = identifyPayload
-            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardingGatewayManager' instead.")
+            logger.warning(
+                "You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardingGatewayManager' instead."
+            )
         } else {
             self.identifyPayload = identifyPayload
         }
     }
-    
+
     /// - Parameters:
     ///   - eventLoopGroup: An `EventLoopGroup`.
     ///   - httpClient: A `HTTPClient`.
@@ -203,12 +206,14 @@ public actor BotGatewayManager: GatewayManager {
             var identifyPayload = identifyPayload
             identifyPayload.shard = nil
             self.identifyPayload = identifyPayload
-            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardingGatewayManager' instead.")
+            logger.warning(
+                "You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardingGatewayManager' instead."
+            )
         } else {
             self.identifyPayload = identifyPayload
         }
     }
-    
+
     /// - Parameters:
     ///   - eventLoopGroup: An `EventLoopGroup`.
     ///   - httpClient: A `HTTPClient`.
@@ -258,17 +263,23 @@ public actor BotGatewayManager: GatewayManager {
         logger.debug("Connect method triggered")
         /// Guard we're attempting to connect too fast
         if let connectIn = connectionBackoff.canPerformIn() {
-            logger.warning("Cannot try to connect immediately due to backoff", metadata: [
-                "wait-time": .stringConvertible(connectIn)
-            ])
+            logger.warning(
+                "Cannot try to connect immediately due to backoff",
+                metadata: [
+                    "wait-time": .stringConvertible(connectIn)
+                ]
+            )
             try? await Task.sleep(for: connectIn)
         }
         /// Guard if other connections are in process
         let state = self.state.load(ordering: .relaxed)
         guard [.noConnection, .configured, .stopped].contains(state) else {
-            logger.error("Gateway state doesn't allow a new connection", metadata: [
-                "state": .stringConvertible(state)
-            ])
+            logger.error(
+                "Gateway state doesn't allow a new connection",
+                metadata: [
+                    "state": .stringConvertible(state)
+                ]
+            )
             return
         }
         self.state.store(.connecting, ordering: .relaxed)
@@ -277,7 +288,7 @@ public actor BotGatewayManager: GatewayManager {
         let queries: [(String, String)] = [
             ("v", "\(DiscordGlobalConfiguration.apiVersion)"),
             ("encoding", "json"),
-            ("compress", "zlib-stream")
+            ("compress", "zlib-stream"),
         ]
 
         let decompressorWSExtension: ZlibDecompressorWSExtension
@@ -318,20 +329,26 @@ public actor BotGatewayManager: GatewayManager {
                     }
                 }
 
-                logger.debug("web-socket connection closed", metadata: [
-                    "closeCode": .string(String(reflecting: closeFrame?.closeCode)),
-                    "closeReason": .string(String(reflecting: closeFrame?.reason)),
-                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                ])
+                logger.debug(
+                    "web-socket connection closed",
+                    metadata: [
+                        "closeCode": .string(String(reflecting: closeFrame?.closeCode)),
+                        "closeReason": .string(String(reflecting: closeFrame?.reason)),
+                        "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed)),
+                    ]
+                )
                 await self.onClose(
                     closeReason: .closeFrame(closeFrame),
                     forConnectionWithId: connectionId
                 )
             } catch {
-                logger.debug("web-socket error while connecting to Discord. Will try again", metadata: [
-                    "error": .string(String(reflecting: error)),
-                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                ])
+                logger.debug(
+                    "web-socket error while connecting to Discord. Will try again",
+                    metadata: [
+                        "error": .string(String(reflecting: error)),
+                        "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed)),
+                    ]
+                )
                 self.state.store(.noConnection, ordering: .relaxed)
                 await self.onClose(closeReason: .error(error), forConnectionWithId: connectionId)
             }
@@ -350,7 +367,7 @@ public actor BotGatewayManager: GatewayManager {
             )
         )
     }
-    
+
     /// https://discord.com/developers/docs/topics/gateway-events#update-presence
     public func updatePresence(payload: Gateway.Identify.Presence) {
         self.send(
@@ -363,7 +380,7 @@ public actor BotGatewayManager: GatewayManager {
             )
         )
     }
-    
+
     /// https://discord.com/developers/docs/topics/gateway-events#update-voice-state
     public func updateVoiceState(payload: VoiceStateUpdate) {
         self.send(
@@ -388,17 +405,23 @@ public actor BotGatewayManager: GatewayManager {
     public func makeEventsParseFailureStream() -> AsyncStream<(any Error, ByteBuffer)> {
         self.eventFailures.base
     }
-    
+
     /// Disconnects from Discord.
     /// Doesn't end the event streams.
     public func disconnect() async {
-        logger.debug("Will disconnect", metadata: [
-            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-        ])
-        if self.state.load(ordering: .relaxed) == .stopped {
-            logger.debug("Already disconnected", metadata: [
+        logger.debug(
+            "Will disconnect",
+            metadata: [
                 "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-            ])
+            ]
+        )
+        if self.state.load(ordering: .relaxed) == .stopped {
+            logger.debug(
+                "Already disconnected",
+                metadata: [
+                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                ]
+            )
             return
         }
         self.connectionId.wrappingIncrement(ordering: .relaxed)
@@ -414,7 +437,7 @@ extension BotGatewayManager {
         if let sequenceNumber = event.sequenceNumber {
             self.sequenceNumber = sequenceNumber
         }
-        
+
         switch event.opcode {
         case .heartbeat:
             self.sendPing(forConnectionWithId: self.connectionId.load(ordering: .relaxed))
@@ -425,12 +448,15 @@ extension BotGatewayManager {
         default:
             break
         }
-        
+
         switch event.data {
         case let .invalidSession(canResume):
-            logger.warning("Got invalid session. Will try to reconnect or resume", metadata: [
-                "canResume": .stringConvertible(canResume)
-            ])
+            logger.warning(
+                "Got invalid session. Will try to reconnect or resume",
+                metadata: [
+                    "canResume": .stringConvertible(canResume)
+                ]
+            )
             if !canResume {
                 self.sequenceNumber = nil
                 self.resumeGatewayURL = nil
@@ -450,26 +476,34 @@ extension BotGatewayManager {
             logger.trace("Will resume or identify")
             await self.sendResumeOrIdentify()
         case let .ready(payload):
-            logger.notice("Received ready notice. The connection is fully established", metadata: [
-                "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-            ])
+            logger.notice(
+                "Received ready notice. The connection is fully established",
+                metadata: [
+                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                ]
+            )
             await self.onSuccessfulConnection()
             self.sessionId = payload.session_id
             self.resumeGatewayURL = payload.resume_gateway_url
         case .resumed:
-            logger.debug("Received resume notice. The connection is fully established", metadata: [
-                "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-            ])
+            logger.debug(
+                "Received resume notice. The connection is fully established",
+                metadata: [
+                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                ]
+            )
             await self.onSuccessfulConnection()
         default:
             break
         }
     }
-    
+
     private func getGatewayURL() async -> String {
         logger.debug("Will try to get Discord gateway url")
-        if self.sequenceNumber != nil, /// If can resume at all
-           let gatewayURL = self.resumeGatewayURL {
+        if self.sequenceNumber != nil,
+            /// If can resume at all
+            let gatewayURL = self.resumeGatewayURL
+        {
             logger.trace("Got Discord gateway url from 'resumeGatewayURL'")
             return gatewayURL
         } else {
@@ -478,36 +512,45 @@ extension BotGatewayManager {
                 logger.trace("Got Discord gateway url from gateway api call")
                 return gatewayURL
             } catch {
-                logger.error("Cannot get gateway url to connect to. Will retry in 10 seconds", metadata: [
-                    "error": .string(String(reflecting: error))
-                ])
+                logger.error(
+                    "Cannot get gateway url to connect to. Will retry in 10 seconds",
+                    metadata: [
+                        "error": .string(String(reflecting: error))
+                    ]
+                )
                 try? await Task.sleep(for: .seconds(10))
                 return await self.getGatewayURL()
             }
         }
     }
-    
+
     private func sendResumeOrIdentify() async {
         if let sessionId = self.sessionId,
-           let lastSequenceNumber = self.sequenceNumber {
+            let lastSequenceNumber = self.sequenceNumber
+        {
             self.sendResume(sessionId: sessionId, sequenceNumber: lastSequenceNumber)
         } else {
-            logger.debug("Can't resume last Discord connection. Will identify", metadata: [
-                "sessionId": .stringConvertible(self.sessionId ?? "nil"),
-                "lastSequenceNumber": .stringConvertible(self.sequenceNumber ?? -1)
-            ])
+            logger.debug(
+                "Can't resume last Discord connection. Will identify",
+                metadata: [
+                    "sessionId": .stringConvertible(self.sessionId ?? "nil"),
+                    "lastSequenceNumber": .stringConvertible(self.sequenceNumber ?? -1),
+                ]
+            )
             await self.sendIdentify()
         }
     }
-    
+
     private func sendResume(sessionId: String, sequenceNumber: Int) {
         let resume = Gateway.Event(
             opcode: .resume,
-            data: .resume(.init(
-                token: identifyPayload.token,
-                session_id: sessionId,
-                sequence: sequenceNumber
-            ))
+            data: .resume(
+                .init(
+                    token: identifyPayload.token,
+                    session_id: sessionId,
+                    sequence: sequenceNumber
+                )
+            )
         )
         let opcode = Gateway.Opcode.identify
         self.send(
@@ -521,10 +564,10 @@ extension BotGatewayManager {
         /// This will be a notice for the next connection to
         /// not try resuming anymore, if this connection has failed.
         self.sequenceNumber = nil
-        
+
         logger.debug("Sent resume request to Discord")
     }
-    
+
     private func sendIdentify() async {
         connectionBackoff.willTry()
         let identify = Gateway.Event(
@@ -533,7 +576,7 @@ extension BotGatewayManager {
         )
         self.send(message: .init(payload: identify))
     }
-    
+
     private func processBinaryData(
         _ message: WebSocketMessage,
         forConnectionWithId connectionId: UInt
@@ -543,14 +586,20 @@ extension BotGatewayManager {
         let buffer: ByteBuffer
         switch message {
         case .text(let string):
-            self.logger.debug("Got text from websocket", metadata: [
-                "text": .string(string)
-            ])
+            self.logger.debug(
+                "Got text from websocket",
+                metadata: [
+                    "text": .string(string)
+                ]
+            )
             buffer = ByteBuffer(string: string)
         case .binary(let _buffer):
-            self.logger.debug("Got binary from websocket", metadata: [
-                "text": .string(String(buffer: _buffer))
-            ])
+            self.logger.debug(
+                "Got binary from websocket",
+                metadata: [
+                    "text": .string(String(buffer: _buffer))
+                ]
+            )
             buffer = _buffer
         }
 
@@ -559,20 +608,24 @@ extension BotGatewayManager {
                 Gateway.Event.self,
                 from: Data(buffer: buffer, byteTransferStrategy: .noCopy)
             )
-            self.logger.debug("Decoded event with opcode", metadata: [
-                "opcode": .string(event.opcode.description)
-            ])
-            self.logger.debug("Decoded event", metadata: [
-                "event": .string("\(event)")
-            ])
+            self.logger.debug(
+                "Decoded event",
+                metadata: [
+                    "event": .string("\(event)"),
+                    "opcode": .string(event.opcode.description),
+                ]
+            )
             Task { await self.processEvent(event) }
             for continuation in self.eventsStreamContinuations {
                 continuation.yield(event)
             }
         } catch {
-            self.logger.debug("Failed to decode event", metadata: [
-                "error": .string("\(error)")
-            ])
+            self.logger.debug(
+                "Failed to decode event",
+                metadata: [
+                    "error": .string("\(error)")
+                ]
+            )
             for continuation in self.eventsParseFailureContinuations {
                 continuation.yield((error, buffer))
             }
@@ -599,28 +652,33 @@ extension BotGatewayManager {
                 "code": .string(codeDesc),
                 "closedConnectionId": .stringConvertible(
                     self.connectionId.load(ordering: .relaxed)
-                )
+                ),
             ]
         )
         if self.canTryReconnect(code: code) {
             self.state.store(.noConnection, ordering: .relaxed)
-            self.logger.trace("Will try reconnect since Discord does allow it.", metadata: [
-                "code": .string(codeDesc),
-                "closedConnectionId": .stringConvertible(
-                    self.connectionId.load(ordering: .relaxed)
-                )
-            ])
+            self.logger.trace(
+                "Will try reconnect since Discord does allow it.",
+                metadata: [
+                    "code": .string(codeDesc),
+                    "closedConnectionId": .stringConvertible(
+                        self.connectionId.load(ordering: .relaxed)
+                    ),
+                ]
+            )
             await self.connect()
         } else {
             self.state.store(.stopped, ordering: .relaxed)
             self.connectionId.wrappingIncrement(ordering: .relaxed)
-            self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/DiscordBM/DiscordBM/issues if you think this is a library issue")
+            self.logger.critical(
+                "Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/DiscordBM/DiscordBM/issues if you think this is a library issue"
+            )
 
             /// Don't remove/end the event streams just to stop apps from crashing/restarting
             /// which could result in bot-token revocations or even temporary ip bans.
         }
     }
-    
+
     private nonisolated func getCloseCodeAndDescription(
         of closeReason: CloseReason
     ) -> (WebSocketErrorCode?, String) {
@@ -647,7 +705,7 @@ extension BotGatewayManager {
             return (code, description)
         }
     }
-    
+
     private nonisolated func canTryReconnect(code: WebSocketErrorCode?) -> Bool {
         switch code {
         case let .unknown(codeNumber):
@@ -656,7 +714,7 @@ extension BotGatewayManager {
         default: return true
         }
     }
-    
+
     private func setupPingTask(
         forConnectionWithId connectionId: UInt,
         every duration: Duration
@@ -664,23 +722,32 @@ extension BotGatewayManager {
         Task {
             try? await Task.sleep(for: duration)
             guard self.connectionId.load(ordering: .relaxed) == connectionId else {
-                self.logger.trace("Canceled a ping task", metadata: [
-                    "connectionId": .stringConvertible(connectionId)
-                ])
-                return /// cancel
+                self.logger.trace(
+                    "Canceled a ping task",
+                    metadata: [
+                        "connectionId": .stringConvertible(connectionId)
+                    ]
+                )
+                return/// cancel
             }
-            self.logger.debug("Will send automatic ping", metadata: [
-                "connectionId": .stringConvertible(connectionId)
-            ])
+            self.logger.debug(
+                "Will send automatic ping",
+                metadata: [
+                    "connectionId": .stringConvertible(connectionId)
+                ]
+            )
             self.sendPing(forConnectionWithId: connectionId)
             self.setupPingTask(forConnectionWithId: connectionId, every: duration)
         }
     }
-    
+
     private func sendPing(forConnectionWithId connectionId: UInt) {
-        logger.trace("Will ping", metadata: [
-            "connectionId": .stringConvertible(connectionId)
-        ])
+        logger.trace(
+            "Will ping",
+            metadata: [
+                "connectionId": .stringConvertible(connectionId)
+            ]
+        )
         self.send(
             message: .init(
                 payload: .init(
@@ -703,9 +770,12 @@ extension BotGatewayManager {
                 self.unsuccessfulPingsCount += 1
             }
             if unsuccessfulPingsCount > 2 {
-                logger.debug("Too many unsuccessful pings. Will try to reconnect", metadata: [
-                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                ])
+                logger.debug(
+                    "Too many unsuccessful pings. Will try to reconnect",
+                    metadata: [
+                        "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                    ]
+                )
                 self.state.store(.noConnection, ordering: .relaxed)
                 await self.connect()
             }
@@ -720,9 +790,12 @@ extension BotGatewayManager {
             case .connected:
                 break
             case .stopped:
-                logger.warning("Will not send message because bot is stopped", metadata: [
-                    "message": .string("\(message)")
-                ])
+                logger.warning(
+                    "Will not send message because bot is stopped",
+                    metadata: [
+                        "message": .string("\(message)")
+                    ]
+                )
                 return
             case .noConnection, .connecting, .configured:
                 switch message.payload.opcode.isSentForConnectionEstablishment {
@@ -736,35 +809,46 @@ extension BotGatewayManager {
                 }
             }
             if let connectionId = message.connectionId,
-               self.connectionId.load(ordering: .relaxed) != connectionId {
+                self.connectionId.load(ordering: .relaxed) != connectionId
+            {
                 return
             }
             Task {
-                let opcode: WebSocketOpcode = message.opcode ?? .init(
-                    encodedWebSocketOpcode: message.payload.opcode.rawValue
-                )!
+                let opcode: WebSocketOpcode =
+                    message.opcode ?? .init(
+                        encodedWebSocketOpcode: message.payload.opcode.rawValue
+                    )!
 
                 let data: Data
                 do {
                     data = try DiscordGlobalConfiguration.encoder.encode(message.payload)
                 } catch {
-                    self.logger.error("Could not encode payload", metadata: [
-                        "payload": .string("\(message.payload)"),
-                        "opcode": .stringConvertible(opcode),
-                        "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                    ])
+                    self.logger.error(
+                        "Could not encode payload",
+                        metadata: [
+                            "payload": .string("\(message.payload)"),
+                            "opcode": .stringConvertible(opcode),
+                            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed)),
+                        ]
+                    )
                     return
                 }
 
                 if let outboundWriter = await self.outboundWriter {
                     do {
-                        self.logger.debug("Will send a payload with opcode", metadata: [
-                            "opcode": .string(message.payload.opcode.description)
-                        ])
-                        self.logger.trace("Will send a payload", metadata: [
-                            "payload": .string("\(message.payload)"),
-                            "opcode": .stringConvertible(opcode)
-                        ])
+                        self.logger.debug(
+                            "Will send a payload with opcode",
+                            metadata: [
+                                "opcode": .string(message.payload.opcode.description)
+                            ]
+                        )
+                        self.logger.trace(
+                            "Will send a payload",
+                            metadata: [
+                                "payload": .string("\(message.payload)"),
+                                "opcode": .stringConvertible(opcode),
+                            ]
+                        )
                         try await outboundWriter.write(
                             .custom(
                                 .init(
@@ -776,22 +860,31 @@ extension BotGatewayManager {
                         )
                     } catch {
                         if let channelError = error as? ChannelError,
-                           case .ioOnClosedChannel = channelError {
-                            self.logger.error("Received 'ChannelError.ioOnClosedChannel' error while sending payload through web-socket. Will fully disconnect and reconnect again")
+                            case .ioOnClosedChannel = channelError
+                        {
+                            self.logger.error(
+                                "Received 'ChannelError.ioOnClosedChannel' error while sending payload through web-socket. Will fully disconnect and reconnect again"
+                            )
                             await self.disconnect()
                             await self.connect()
                         } else if message.payload.opcode == .heartbeat,
-                                  let writerError = error as? NIOAsyncWriterError,
-                                  writerError == .alreadyFinished() {
-                            self.logger.debug("Received 'NIOAsyncWriterError.alreadyFinished' error while sending heartbeat through web-socket. Will ignore")
+                            let writerError = error as? NIOAsyncWriterError,
+                            writerError == .alreadyFinished()
+                        {
+                            self.logger.debug(
+                                "Received 'NIOAsyncWriterError.alreadyFinished' error while sending heartbeat through web-socket. Will ignore"
+                            )
                         } else {
-                            self.logger.error("Could not send payload through web-socket", metadata: [
-                                "error": .string(String(reflecting: error)),
-                                "payload": .string("\(message.payload)"),
-                                "opcode": .stringConvertible(opcode),
-                                "state": .stringConvertible(self.state.load(ordering: .relaxed)),
-                                "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                            ])
+                            self.logger.error(
+                                "Could not send payload through web-socket",
+                                metadata: [
+                                    "error": .string(String(reflecting: error)),
+                                    "payload": .string("\(message.payload)"),
+                                    "opcode": .stringConvertible(opcode),
+                                    "state": .stringConvertible(self.state.load(ordering: .relaxed)),
+                                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed)),
+                                ]
+                            )
                         }
                     }
                 } else {
@@ -805,8 +898,9 @@ extension BotGatewayManager {
                         metadata: [
                             "payload": .string("\(message.payload)"),
                             "state": .stringConvertible(self.state.load(ordering: .relaxed)),
-                            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                        ])
+                            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed)),
+                        ]
+                    )
                 }
             }
         }
@@ -826,13 +920,14 @@ extension BotGatewayManager {
     /// Maybe soon with some `DistributedActor`s magic.
     private func waitInShardQueueIfNeeded() async {
         if let shardInfo,
-           /// If shard already connected once before, then skip the wait.
-           !shardInfo.shardConnectedOnceBefore {
+            /// If shard already connected once before, then skip the wait.
+            !shardInfo.shardConnectedOnceBefore
+        {
             logger.trace("Will wait for other shards")
             /// `shardManager` must exist. Initializer must enforce this.
             await shardInfo.shardCoordinator.waitForOtherShards(
                 shard: shardInfo.shard,
-                maxConcurrency: max(shardInfo.maxConcurrency, 1) /// Avoid an unlikely division-by-zero
+                maxConcurrency: max(shardInfo.maxConcurrency, 1)/// Avoid an unlikely division-by-zero
             )
             logger.trace("Done waiting for other shards")
         }
@@ -847,9 +942,12 @@ extension BotGatewayManager {
         do {
             try await self.outboundWriter?.close(.goingAway, reason: nil)
         } catch {
-            logger.warning("Will ignore WS closure failure", metadata: [
-                "error": .string(String(reflecting: error))
-            ])
+            logger.warning(
+                "Will ignore WS closure failure",
+                metadata: [
+                    "error": .string(String(reflecting: error))
+                ]
+            )
         }
         self.outboundWriter = nil
     }
@@ -891,7 +989,9 @@ private enum GatewayState: Int, Sendable, AtomicValue, CustomStringConvertible {
 extension Gateway.Opcode {
     var isSentForConnectionEstablishment: Bool {
         switch self {
-        case .dispatch, .presenceUpdate, .voiceStateUpdate, .reconnect, .requestGuildMembers, .invalidSession, .hello, .heartbeatAccepted, .heartbeat: false
+        case .dispatch, .presenceUpdate, .voiceStateUpdate, .reconnect, .requestGuildMembers, .invalidSession, .hello,
+            .heartbeatAccepted, .heartbeat:
+            false
         case .identify, .resume: true
         }
     }

commit 63a527e6f7b8e82dc338f49d379d80f9c4f314fa
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon Dec 30 15:26:33 2024 +0330

    Fixes for sending stuff through Gateway with swift-websocket (#84)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 251fbd5..9fd2773 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -5,6 +5,7 @@ import Atomics
 import Logging
 import DiscordModels
 import NIO
+import struct NIOWebSocket.WebSocketOpcode
 import enum NIOWebSocket.WebSocketErrorCode
 
 public actor BotGatewayManager: GatewayManager {
@@ -22,7 +23,26 @@ public actor BotGatewayManager: GatewayManager {
             self.shardCoordinator = shardCoordinator
         }
     }
-    
+
+    private struct Message {
+        let payload: Gateway.Event
+        let opcode: WebSocketOpcode?
+        let connectionId: UInt?
+        var tryCount: Int
+
+        init(
+            payload: Gateway.Event,
+            opcode: WebSocketOpcode? = nil,
+            connectionId: UInt? = nil,
+            tryCount: Int = 0
+        ) {
+            self.payload = payload
+            self.opcode = opcode
+            self.connectionId = connectionId
+            self.tryCount = tryCount
+        }
+    }
+
     var outboundWriter: WebSocketOutboundWriter?
     let eventLoopGroup: any EventLoopGroup
     /// A client to send requests to Discord.
@@ -67,7 +87,7 @@ public actor BotGatewayManager: GatewayManager {
     /// 120 per 60 seconds (1 every 500ms),
     /// per https://discord.com/developers/docs/topics/gateway#rate-limiting
     let sendQueue = SerialQueue(waitTime: .milliseconds(500))
-    
+
     //MARK: Current connection properties
     
     /// An ID to keep track of connection changes.
@@ -237,7 +257,7 @@ public actor BotGatewayManager: GatewayManager {
     public func connect() async {
         logger.debug("Connect method triggered")
         /// Guard we're attempting to connect too fast
-        if let connectIn = await connectionBackoff.canPerformIn() {
+        if let connectIn = connectionBackoff.canPerformIn() {
             logger.warning("Cannot try to connect immediately due to backoff", metadata: [
                 "wait-time": .stringConvertible(connectIn)
             ])
@@ -320,29 +340,41 @@ public actor BotGatewayManager: GatewayManager {
 
     /// https://discord.com/developers/docs/topics/gateway-events#request-guild-members
     public func requestGuildMembersChunk(payload: Gateway.RequestGuildMembers) {
-        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
-        self.send(payload: .init(
-            opcode: .requestGuildMembers,
-            data: .requestGuildMembers(payload)
-        ), opcode: 1)
+        self.send(
+            message: .init(
+                payload: .init(
+                    opcode: .requestGuildMembers,
+                    data: .requestGuildMembers(payload)
+                ),
+                opcode: .text
+            )
+        )
     }
     
     /// https://discord.com/developers/docs/topics/gateway-events#update-presence
     public func updatePresence(payload: Gateway.Identify.Presence) {
-        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
-        self.send(payload: .init(
-            opcode: .presenceUpdate,
-            data: .requestPresenceUpdate(payload)
-        ), opcode: 1)
+        self.send(
+            message: .init(
+                payload: .init(
+                    opcode: .presenceUpdate,
+                    data: .requestPresenceUpdate(payload)
+                ),
+                opcode: .text
+            )
+        )
     }
     
     /// https://discord.com/developers/docs/topics/gateway-events#update-voice-state
     public func updateVoiceState(payload: VoiceStateUpdate) {
-        /// This took a lot of time to figure out, not sure why it needs opcode `10` (works with `9` too?!).
-        self.send(payload: .init(
-            opcode: .voiceStateUpdate,
-            data: .requestVoiceStateUpdate(payload)
-        ), opcode: 10)
+        self.send(
+            message: .init(
+                payload: .init(
+                    opcode: .voiceStateUpdate,
+                    data: .requestVoiceStateUpdate(payload)
+                ),
+                opcode: .text
+            )
+        )
     }
 
     /// Makes an stream of Gateway events.
@@ -371,7 +403,7 @@ public actor BotGatewayManager: GatewayManager {
         }
         self.connectionId.wrappingIncrement(ordering: .relaxed)
         self.state.store(.stopped, ordering: .relaxed)
-        await connectionBackoff.resetTryCount()
+        connectionBackoff.resetTryCount()
         await self.sendQueue.reset()
         await self.closeWebSocket()
     }
@@ -477,11 +509,14 @@ extension BotGatewayManager {
                 sequence: sequenceNumber
             ))
         )
+        let opcode = Gateway.Opcode.identify
         self.send(
-            payload: resume,
-            opcode: Gateway.Opcode.identify.rawValue
+            message: .init(
+                payload: resume,
+                opcode: .init(encodedWebSocketOpcode: opcode.rawValue)!
+            )
         )
-        
+
         /// Invalidate `sequenceNumber` info for the next connection, incase this one fails.
         /// This will be a notice for the next connection to
         /// not try resuming anymore, if this connection has failed.
@@ -491,12 +526,12 @@ extension BotGatewayManager {
     }
     
     private func sendIdentify() async {
-        await connectionBackoff.willTry()
+        connectionBackoff.willTry()
         let identify = Gateway.Event(
             opcode: .identify,
             data: .identify(identifyPayload)
         )
-        self.send(payload: identify)
+        self.send(message: .init(payload: identify))
     }
     
     private func processBinaryData(
@@ -524,6 +559,9 @@ extension BotGatewayManager {
                 Gateway.Event.self,
                 from: Data(buffer: buffer, byteTransferStrategy: .noCopy)
             )
+            self.logger.debug("Decoded event with opcode", metadata: [
+                "opcode": .string(event.opcode.description)
+            ])
             self.logger.debug("Decoded event", metadata: [
                 "event": .string("\(event)")
             ])
@@ -643,10 +681,14 @@ extension BotGatewayManager {
         logger.trace("Will ping", metadata: [
             "connectionId": .stringConvertible(connectionId)
         ])
-        self.send(payload: .init(
-            opcode: .heartbeat,
-            data: .heartbeat(lastSequenceNumber: self.sequenceNumber)
-        ))
+        self.send(
+            message: .init(
+                payload: .init(
+                    opcode: .heartbeat,
+                    data: .heartbeat(lastSequenceNumber: self.sequenceNumber)
+                )
+            )
+        )
         Task {
             try? await Task.sleep(for: .seconds(10))
             guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
@@ -670,45 +712,64 @@ extension BotGatewayManager {
         }
     }
 
-    private nonisolated func send(
-        payload: Gateway.Event,
-        opcode: UInt8? = nil,
-        connectionId: UInt? = nil,
-        tryCount: Int = 0
-    ) {
+    private nonisolated func send(message: Message) {
         self.sendQueue.perform { [weak self] in
             guard let self = self else { return }
-            Task {
-                if let connectionId,
-                   self.connectionId.load(ordering: .relaxed) != connectionId {
+            let state = self.state.load(ordering: .relaxed)
+            switch state {
+            case .connected:
+                break
+            case .stopped:
+                logger.warning("Will not send message because bot is stopped", metadata: [
+                    "message": .string("\(message)")
+                ])
+                return
+            case .noConnection, .connecting, .configured:
+                switch message.payload.opcode.isSentForConnectionEstablishment {
+                case true:
+                    break
+                case false:
+                    /// Recursively try to send through the queue.
+                    /// The send queue has slowdown mechanisms so it's fine.
+                    self.send(message: message)
                     return
                 }
-                
-                let opcode = opcode ?? payload.opcode.rawValue
-                
+            }
+            if let connectionId = message.connectionId,
+               self.connectionId.load(ordering: .relaxed) != connectionId {
+                return
+            }
+            Task {
+                let opcode: WebSocketOpcode = message.opcode ?? .init(
+                    encodedWebSocketOpcode: message.payload.opcode.rawValue
+                )!
+
                 let data: Data
                 do {
-                    data = try DiscordGlobalConfiguration.encoder.encode(payload)
+                    data = try DiscordGlobalConfiguration.encoder.encode(message.payload)
                 } catch {
                     self.logger.error("Could not encode payload", metadata: [
-                        "payload": .string("\(payload)"),
+                        "payload": .string("\(message.payload)"),
                         "opcode": .stringConvertible(opcode),
                         "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                     ])
                     return
                 }
-                
+
                 if let outboundWriter = await self.outboundWriter {
                     do {
+                        self.logger.debug("Will send a payload with opcode", metadata: [
+                            "opcode": .string(message.payload.opcode.description)
+                        ])
                         self.logger.trace("Will send a payload", metadata: [
-                            "payload": .string("\(payload)"),
+                            "payload": .string("\(message.payload)"),
                             "opcode": .stringConvertible(opcode)
                         ])
                         try await outboundWriter.write(
                             .custom(
                                 .init(
                                     fin: true,
-                                    opcode: .init(encodedWebSocketOpcode: opcode)!,
+                                    opcode: opcode,
                                     data: ByteBuffer(data: data)
                                 )
                             )
@@ -719,15 +780,16 @@ extension BotGatewayManager {
                             self.logger.error("Received 'ChannelError.ioOnClosedChannel' error while sending payload through web-socket. Will fully disconnect and reconnect again")
                             await self.disconnect()
                             await self.connect()
-                        } else if payload.opcode == .heartbeat,
+                        } else if message.payload.opcode == .heartbeat,
                                   let writerError = error as? NIOAsyncWriterError,
                                   writerError == .alreadyFinished() {
                             self.logger.debug("Received 'NIOAsyncWriterError.alreadyFinished' error while sending heartbeat through web-socket. Will ignore")
                         } else {
                             self.logger.error("Could not send payload through web-socket", metadata: [
-                                "error": .string("\(error)"),
-                                "payload": .string("\(payload)"),
+                                "error": .string(String(reflecting: error)),
+                                "payload": .string("\(message.payload)"),
                                 "opcode": .stringConvertible(opcode),
+                                "state": .stringConvertible(self.state.load(ordering: .relaxed)),
                                 "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                             ])
                         }
@@ -738,10 +800,10 @@ extension BotGatewayManager {
                     /// so long story short, the gateway manager never gets stuck in a bad
                     /// cycle of no-connection.
                     self.logger.log(
-                        level: (payload.opcode == .heartbeat) ? .debug : .warning,
+                        level: (message.payload.opcode == .heartbeat) ? .debug : .warning,
                         "Trying to send through ws when a connection is not established",
                         metadata: [
-                            "payload": .string("\(payload)"),
+                            "payload": .string("\(message.payload)"),
                             "state": .stringConvertible(self.state.load(ordering: .relaxed)),
                             "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                         ])
@@ -749,10 +811,10 @@ extension BotGatewayManager {
             }
         }
     }
-    
+
     private func onSuccessfulConnection() async {
         self.state.store(.connected, ordering: .relaxed)
-        await connectionBackoff.resetTryCount()
+        connectionBackoff.resetTryCount()
         self.unsuccessfulPingsCount = 0
         await self.sendQueue.reset()
     }
@@ -780,7 +842,7 @@ extension BotGatewayManager {
         self.outboundWriter = outboundWriter
     }
 
-    private nonisolated func closeWebSocket() async {
+    private func closeWebSocket() async {
         logger.debug("Will possibly close a web-socket")
         do {
             try await self.outboundWriter?.close(.goingAway, reason: nil)
@@ -789,6 +851,7 @@ extension BotGatewayManager {
                 "error": .string(String(reflecting: error))
             ])
         }
+        self.outboundWriter = nil
     }
 }
 
@@ -823,3 +886,13 @@ private enum GatewayState: Int, Sendable, AtomicValue, CustomStringConvertible {
         }
     }
 }
+
+// MARK: - +Gateway.Opcode
+extension Gateway.Opcode {
+    var isSentForConnectionEstablishment: Bool {
+        switch self {
+        case .dispatch, .presenceUpdate, .voiceStateUpdate, .reconnect, .requestGuildMembers, .invalidSession, .hello, .heartbeatAccepted, .heartbeat: false
+        case .identify, .resume: true
+        }
+    }
+}

commit 0b0a17d1668eb0f21a7b6c551df32aefe24e4bd4
Author: MahdiBM <github@mahdibm.com>
Date:   Mon Dec 23 11:56:56 2024 +0330

    logging improvements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index d132ba7..251fbd5 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -722,7 +722,7 @@ extension BotGatewayManager {
                         } else if payload.opcode == .heartbeat,
                                   let writerError = error as? NIOAsyncWriterError,
                                   writerError == .alreadyFinished() {
-                            self.logger.warning("Received 'NIOAsyncWriterError.alreadyFinished' error while sending heartbeat through web-socket. Will ignore")
+                            self.logger.debug("Received 'NIOAsyncWriterError.alreadyFinished' error while sending heartbeat through web-socket. Will ignore")
                         } else {
                             self.logger.error("Could not send payload through web-socket", metadata: [
                                 "error": .string("\(error)"),

commit 53f2358be4b267355a59920a826ebc8861045564
Author: MahdiBM <github@mahdibm.com>
Date:   Sat Dec 21 15:30:46 2024 +0330

    Ignore `NIOAsyncWriterError.alreadyFinished` errors when heartbeat-ing

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 359dfb8..d132ba7 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -719,6 +719,10 @@ extension BotGatewayManager {
                             self.logger.error("Received 'ChannelError.ioOnClosedChannel' error while sending payload through web-socket. Will fully disconnect and reconnect again")
                             await self.disconnect()
                             await self.connect()
+                        } else if payload.opcode == .heartbeat,
+                                  let writerError = error as? NIOAsyncWriterError,
+                                  writerError == .alreadyFinished() {
+                            self.logger.warning("Received 'NIOAsyncWriterError.alreadyFinished' error while sending heartbeat through web-socket. Will ignore")
                         } else {
                             self.logger.error("Could not send payload through web-socket", metadata: [
                                 "error": .string("\(error)"),

commit ba570e61c670ca9b7effb99282fa61f94cf4ed9d
Author: MahdiBM <github@mahdibm.com>
Date:   Thu Dec 19 16:50:39 2024 +0330

    logging enhancements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 467b112..359dfb8 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -298,19 +298,22 @@ public actor BotGatewayManager: GatewayManager {
                     }
                 }
 
-                logger.error("web-socket connection closed", metadata: [
+                logger.debug("web-socket connection closed", metadata: [
                     "closeCode": .string(String(reflecting: closeFrame?.closeCode)),
                     "closeReason": .string(String(reflecting: closeFrame?.reason)),
                     "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                 ])
-                await self.onClose(closeFrame: closeFrame, forConnectionWithId: connectionId)
+                await self.onClose(
+                    closeReason: .closeFrame(closeFrame),
+                    forConnectionWithId: connectionId
+                )
             } catch {
-                logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
-                    "error": .string("\(String(reflecting: error))"),
+                logger.debug("web-socket error while connecting to Discord. Will try again", metadata: [
+                    "error": .string(String(reflecting: error)),
                     "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                 ])
                 self.state.store(.noConnection, ordering: .relaxed)
-                await self.onClose(closeFrame: nil, forConnectionWithId: connectionId)
+                await self.onClose(closeReason: .error(error), forConnectionWithId: connectionId)
             }
         }
     }
@@ -537,14 +540,19 @@ extension BotGatewayManager {
             }
         }
     }
-    
+
+    private enum CloseReason {
+        case closeFrame(WebSocketCloseFrame?)
+        case error(any Error)
+    }
+
     private func onClose(
-        closeFrame: WebSocketCloseFrame?,
+        closeReason: CloseReason,
         forConnectionWithId connectionId: UInt
     ) async {
         self.logger.debug("Received connection close notification for a web-socket")
         guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
-        let (code, codeDesc) = self.getCloseCodeAndDescription(of: closeFrame)
+        let (code, codeDesc) = self.getCloseCodeAndDescription(of: closeReason)
         let isDebugLevelCode = [nil, .goingAway, .unexpectedServerError].contains(code)
         self.logger.log(
             level: isDebugLevelCode ? .debug : .warning,
@@ -556,7 +564,7 @@ extension BotGatewayManager {
                 )
             ]
         )
-        if self.canTryReconnect(code: closeFrame?.closeCode) {
+        if self.canTryReconnect(code: code) {
             self.state.store(.noConnection, ordering: .relaxed)
             self.logger.trace("Will try reconnect since Discord does allow it.", metadata: [
                 "code": .string(codeDesc),
@@ -576,25 +584,30 @@ extension BotGatewayManager {
     }
     
     private nonisolated func getCloseCodeAndDescription(
-        of closeFrame: WebSocketCloseFrame?
+        of closeReason: CloseReason
     ) -> (WebSocketErrorCode?, String) {
-        guard let closeFrame else {
-            return (nil, "nil")
-        }
-        let code = closeFrame.closeCode
-        let description: String
-        switch code {
-        case let .unknown(codeNumber):
-            switch GatewayCloseCode(rawValue: codeNumber) {
-            case let .some(discordCode):
-                description = "\(discordCode)"
-            case .none:
-                description = "\(codeNumber)"
+        switch closeReason {
+        case .error(let error):
+            return (nil, String(reflecting: error))
+        case .closeFrame(let closeFrame):
+            guard let closeFrame else {
+                return (nil, "nil")
             }
-        default:
-            description = closeFrame.reason ?? "\(code)"
+            let code = closeFrame.closeCode
+            let description: String
+            switch code {
+            case let .unknown(codeNumber):
+                switch GatewayCloseCode(rawValue: codeNumber) {
+                case let .some(discordCode):
+                    description = "\(discordCode)"
+                case .none:
+                    description = "\(codeNumber)"
+                }
+            default:
+                description = closeFrame.reason ?? "\(code)"
+            }
+            return (code, description)
         }
-        return (code, description)
     }
     
     private nonisolated func canTryReconnect(code: WebSocketErrorCode?) -> Bool {

commit 7210d9c4b5549b49e78fb9e1b267cbf05391b85a
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Thu Dec 19 14:43:32 2024 +0330

    Use swift-websocket, require Swift 5.10 (#81)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 6e236ae..467b112 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -1,4 +1,4 @@
-import DiscordWebSocket
+import WSClient
 import Foundation
 import AsyncHTTPClient
 import Atomics
@@ -23,7 +23,7 @@ public actor BotGatewayManager: GatewayManager {
         }
     }
     
-    var ws: WebSocket?
+    var outboundWriter: WebSocketOutboundWriter?
     let eventLoopGroup: any EventLoopGroup
     /// A client to send requests to Discord.
     public nonisolated let client: any DiscordClient
@@ -259,43 +259,59 @@ public actor BotGatewayManager: GatewayManager {
             ("encoding", "json"),
             ("compress", "zlib-stream")
         ]
-        let configuration = WebSocketClient.Configuration(
+
+        let decompressorWSExtension: ZlibDecompressorWSExtension
+        do {
+            decompressorWSExtension = try ZlibDecompressorWSExtension(logger: self.logger)
+        } catch {
+            self.logger.critical(
+                "Will not connect because can't create a decompressor. Something is wrong. Please report this failure at https://github.com/DiscordBM/DiscordBM/issues",
+                metadata: ["error": .string(String(reflecting: error))]
+            )
+            return
+        }
+
+        let configuration = WebSocketClientConfiguration(
             maxFrameSize: self.maxFrameSize,
-            decompression: .enabled
+            extensions: [.nonNegotiatedExtension { decompressorWSExtension }]
         )
         logger.trace("Will try to connect to Discord through web-socket")
-        do {
-            let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
-            let setWebSocket: @Sendable (WebSocket) async -> Void = { ws in
-                await self.closeWebSocket(ws: self.ws)
-                await self.setWebSocket(ws: ws)
-            }
-            let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
-                Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
-            }
-            let onClose: @Sendable (WebSocket) -> Void = { ws in
-                Task { await self.setupOnClose(ws: ws, forConnectionWithId: connectionId) }
+        let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
+        /// FIXME: remove this `Task` in a future major version.
+        /// This is so the `connect()` method does still exit, like it used to.
+        /// But for proper structured concurrency, this method should never exit (optimally).
+        Task {
+            do {
+                let closeFrame = try await WebSocketClient.connect(
+                    url: gatewayURL + queries.makeForURLQuery(),
+                    configuration: configuration,
+                    eventLoopGroup: self.eventLoopGroup,
+                    logger: self.logger
+                ) { inbound, outbound, context in
+                    await self.setupOutboundWriter(outbound)
+
+                    self.logger.debug("Connected to Discord through web-socket. Will configure")
+                    self.state.store(.configured, ordering: .relaxed)
+
+                    for try await message in inbound.messages(maxSize: self.maxFrameSize) {
+                        await self.processBinaryData(message, forConnectionWithId: connectionId)
+                    }
+                }
+
+                logger.error("web-socket connection closed", metadata: [
+                    "closeCode": .string(String(reflecting: closeFrame?.closeCode)),
+                    "closeReason": .string(String(reflecting: closeFrame?.reason)),
+                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                ])
+                await self.onClose(closeFrame: closeFrame, forConnectionWithId: connectionId)
+            } catch {
+                logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
+                    "error": .string("\(String(reflecting: error))"),
+                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                ])
+                self.state.store(.noConnection, ordering: .relaxed)
+                await self.onClose(closeFrame: nil, forConnectionWithId: connectionId)
             }
-            /// Not removing the returned `WebSocket` for tests compatibility.
-            /// The actual setting of `self.ws` to the new `WebSocket` happens in
-            /// the `setWebSocket` parameter. This is to try to avoid a weird bug where
-            /// `WebSocket.connect()` returns the `WebSocket` _before_ the first event is received.
-            _ = try await WebSocket.connect(
-                to: gatewayURL + queries.makeForURLQuery(),
-                configuration: configuration,
-                on: eventLoopGroup,
-                setWebSocket: setWebSocket,
-                onBuffer: onBuffer,
-                onClose: onClose
-            )
-            self.logger.debug("Connected to Discord through web-socket. Will configure")
-            self.state.store(.configured, ordering: .relaxed)
-        } catch {
-            logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
-                "error": .string("\(error)")
-            ])
-            self.state.store(.noConnection, ordering: .relaxed)
-            await self.connect()
         }
     }
 
@@ -354,7 +370,7 @@ public actor BotGatewayManager: GatewayManager {
         self.state.store(.stopped, ordering: .relaxed)
         await connectionBackoff.resetTryCount()
         await self.sendQueue.reset()
-        self.closeWebSocket(ws: self.ws)
+        await self.closeWebSocket()
     }
 }
 
@@ -422,11 +438,14 @@ extension BotGatewayManager {
             logger.trace("Got Discord gateway url from 'resumeGatewayURL'")
             return gatewayURL
         } else {
-            if let gatewayURL = try? await client.getGateway().decode().url {
+            do {
+                let gatewayURL = try await client.getGateway().decode().url
                 logger.trace("Got Discord gateway url from gateway api call")
                 return gatewayURL
-            } else {
-                logger.error("Cannot get gateway url to connect to. Will retry in 10 seconds")
+            } catch {
+                logger.error("Cannot get gateway url to connect to. Will retry in 10 seconds", metadata: [
+                    "error": .string(String(reflecting: error))
+                ])
                 try? await Task.sleep(for: .seconds(10))
                 return await self.getGatewayURL()
             }
@@ -477,16 +496,30 @@ extension BotGatewayManager {
         self.send(payload: identify)
     }
     
-    private func processBinaryData(_ buffer: ByteBuffer, forConnectionWithId connectionId: UInt) {
-        self.logger.debug("Got text from websocket", metadata: [
-            "text": .string(String(buffer: buffer))
-        ])
+    private func processBinaryData(
+        _ message: WebSocketMessage,
+        forConnectionWithId connectionId: UInt
+    ) {
         guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
-        let data = Data(buffer: buffer)
+
+        let buffer: ByteBuffer
+        switch message {
+        case .text(let string):
+            self.logger.debug("Got text from websocket", metadata: [
+                "text": .string(string)
+            ])
+            buffer = ByteBuffer(string: string)
+        case .binary(let _buffer):
+            self.logger.debug("Got binary from websocket", metadata: [
+                "text": .string(String(buffer: _buffer))
+            ])
+            buffer = _buffer
+        }
+
         do {
             let event = try DiscordGlobalConfiguration.decoder.decode(
                 Gateway.Event.self,
-                from: data
+                from: Data(buffer: buffer, byteTransferStrategy: .noCopy)
             )
             self.logger.debug("Decoded event", metadata: [
                 "event": .string("\(event)")
@@ -505,40 +538,50 @@ extension BotGatewayManager {
         }
     }
     
-    private func setupOnClose(ws: WebSocket, forConnectionWithId connectionId: UInt) {
+    private func onClose(
+        closeFrame: WebSocketCloseFrame?,
+        forConnectionWithId connectionId: UInt
+    ) async {
         self.logger.debug("Received connection close notification for a web-socket")
         guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
-        Task {
-            let (code, codeDesc) = self.getCloseCodeAndDescription(of: ws)
-            let isDebugLevelCode = [nil, .goingAway, .unexpectedServerError].contains(code)
-            self.logger.log(
-                level: isDebugLevelCode ? .debug : .warning,
-                "Received connection close notification. Will try to reconnect",
-                metadata: [
-                    "code": .string(codeDesc),
-                    "closedConnectionId": .stringConvertible(
-                        self.connectionId.load(ordering: .relaxed)
-                    )
-                ]
-            )
-            if self.canTryReconnect(code: ws.closeCode) {
-                self.state.store(.noConnection, ordering: .relaxed)
-                await self.connect()
-            } else {
-                self.state.store(.stopped, ordering: .relaxed)
-                self.connectionId.wrappingIncrement(ordering: .relaxed)
-                self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/DiscordBM/DiscordBM/issues if you think this is a library issue")
+        let (code, codeDesc) = self.getCloseCodeAndDescription(of: closeFrame)
+        let isDebugLevelCode = [nil, .goingAway, .unexpectedServerError].contains(code)
+        self.logger.log(
+            level: isDebugLevelCode ? .debug : .warning,
+            "Received connection close notification. Will try to reconnect",
+            metadata: [
+                "code": .string(codeDesc),
+                "closedConnectionId": .stringConvertible(
+                    self.connectionId.load(ordering: .relaxed)
+                )
+            ]
+        )
+        if self.canTryReconnect(code: closeFrame?.closeCode) {
+            self.state.store(.noConnection, ordering: .relaxed)
+            self.logger.trace("Will try reconnect since Discord does allow it.", metadata: [
+                "code": .string(codeDesc),
+                "closedConnectionId": .stringConvertible(
+                    self.connectionId.load(ordering: .relaxed)
+                )
+            ])
+            await self.connect()
+        } else {
+            self.state.store(.stopped, ordering: .relaxed)
+            self.connectionId.wrappingIncrement(ordering: .relaxed)
+            self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/DiscordBM/DiscordBM/issues if you think this is a library issue")
 
-                /// Don't remove/end the event streams just to stop apps from crashing/restarting
-                /// which could result in bot-token revocations or even temporary ip bans.
-            }
+            /// Don't remove/end the event streams just to stop apps from crashing/restarting
+            /// which could result in bot-token revocations or even temporary ip bans.
         }
     }
     
     private nonisolated func getCloseCodeAndDescription(
-        of ws: WebSocket
+        of closeFrame: WebSocketCloseFrame?
     ) -> (WebSocketErrorCode?, String) {
-        let code = ws.closeCode
+        guard let closeFrame else {
+            return (nil, "nil")
+        }
+        let code = closeFrame.closeCode
         let description: String
         switch code {
         case let .unknown(codeNumber):
@@ -548,10 +591,8 @@ extension BotGatewayManager {
             case .none:
                 description = "\(codeNumber)"
             }
-        case let .some(anyOtherCode):
-            description = "\(anyOtherCode)"
-        case .none:
-            description = "nil"
+        default:
+            description = closeFrame.reason ?? "\(code)"
         }
         return (code, description)
     }
@@ -644,15 +685,20 @@ extension BotGatewayManager {
                     return
                 }
                 
-                if let ws = await self.ws {
+                if let outboundWriter = await self.outboundWriter {
                     do {
                         self.logger.trace("Will send a payload", metadata: [
                             "payload": .string("\(payload)"),
                             "opcode": .stringConvertible(opcode)
                         ])
-                        try await ws.send(
-                            raw: data,
-                            opcode: .init(encodedWebSocketOpcode: opcode)!
+                        try await outboundWriter.write(
+                            .custom(
+                                .init(
+                                    fin: true,
+                                    opcode: .init(encodedWebSocketOpcode: opcode)!,
+                                    data: ByteBuffer(data: data)
+                                )
+                            )
                         )
                     } catch {
                         if let channelError = error as? ChannelError,
@@ -713,15 +759,17 @@ extension BotGatewayManager {
         }
     }
 
-    func setWebSocket(ws: WebSocket) {
-        self.ws = ws
+    func setupOutboundWriter(_ outboundWriter: WebSocketOutboundWriter) {
+        self.outboundWriter = outboundWriter
     }
-    
-    private nonisolated func closeWebSocket(ws: WebSocket?) {
+
+    private nonisolated func closeWebSocket() async {
         logger.debug("Will possibly close a web-socket")
-        ws?.closeWithFuture().whenFailure { error in
-            self.logger.warning("Couldn't close a web-socket properly", metadata: [
-                "error": .string("\(error)")
+        do {
+            try await self.outboundWriter?.close(.goingAway, reason: nil)
+        } catch {
+            logger.warning("Will ignore WS closure failure", metadata: [
+                "error": .string(String(reflecting: error))
             ])
         }
     }

commit 4294246f0fe908ba7c70f436f01d5ba8d54398ee
Author: MahdiBM <github@mahdibm.com>
Date:   Sun Jul 28 10:40:50 2024 +0330

    resolves Xcode 16 beta 4 errors

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index cc7163b..6e236ae 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -66,7 +66,7 @@ public actor BotGatewayManager: GatewayManager {
     
     /// 120 per 60 seconds (1 every 500ms),
     /// per https://discord.com/developers/docs/topics/gateway#rate-limiting
-    var sendQueue = SerialQueue(waitTime: .milliseconds(500))
+    let sendQueue = SerialQueue(waitTime: .milliseconds(500))
     
     //MARK: Current connection properties
     
@@ -615,8 +615,8 @@ extension BotGatewayManager {
             }
         }
     }
-    
-    private func send(
+
+    private nonisolated func send(
         payload: Gateway.Event,
         opcode: UInt8? = nil,
         connectionId: UInt? = nil,

commit ddce0d02aa46102499eb713c9b4a8efd3ad6fa87
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Thu Apr 11 22:51:15 2024 +0330

    Use `HTTPClient.shared` and `HTTPClient.shared.eventLoopGroup` as default `HTTPClient` and `EventLoopGroup` (#68)
    
    * Use `HTTPClient.shared` and `HTTPClient.shared.eventLoopGroup` as default `HTTPClient` and `EventLoopGroup`
    
    * Update README.md
    
    * Update Package.resolved
    
    * don't shutdown the shared `HTTPClient`
    
    * Update DiscordCache.swift
    
    * resolve some warnings and outdated #if s

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 21261e8..cc7163b 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -159,8 +159,8 @@ public actor BotGatewayManager: GatewayManager {
     ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
-        eventLoopGroup: any EventLoopGroup,
-        httpClient: HTTPClient,
+        eventLoopGroup: any EventLoopGroup = HTTPClient.shared.eventLoopGroup,
+        httpClient: HTTPClient = .shared,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int = 1 << 28,
         appId: ApplicationSnowflake? = nil,
@@ -201,8 +201,8 @@ public actor BotGatewayManager: GatewayManager {
     ///   - presence: The initial presence of the bot.
     ///   - intents: The Discord intents you want to receive messages for.
     public init(
-        eventLoopGroup: any EventLoopGroup,
-        httpClient: HTTPClient,
+        eventLoopGroup: any EventLoopGroup = HTTPClient.shared.eventLoopGroup,
+        httpClient: HTTPClient = .shared,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int = 1 << 28,
         token: String,

commit 76ef3a143ce19d8f577f0c44f5d5ed42ee3ce37e
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sat Nov 4 15:48:41 2023 +0330

    `GatewayManager` move to `events` instead of `makeEventsStream()` (#60)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 0de3065..21261e8 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -38,7 +38,24 @@ public actor BotGatewayManager: GatewayManager {
     //MARK: Event streams
     var eventsStreamContinuations = [AsyncStream<Gateway.Event>.Continuation]()
     var eventsParseFailureContinuations = [AsyncStream<(any Error, ByteBuffer)>.Continuation]()
-    
+
+    /// An async sequence of Gateway events.
+    public var events: DiscordAsyncSequence<Gateway.Event> {
+        DiscordAsyncSequence<Gateway.Event>(
+            base: AsyncStream<Gateway.Event> { continuation in
+                self.eventsStreamContinuations.append(continuation)
+            }
+        )
+    }
+    /// An async sequence of Gateway event parse failures.
+    public var eventFailures: DiscordAsyncSequence<(any Error, ByteBuffer)> {
+        DiscordAsyncSequence<(any Error, ByteBuffer)>(
+            base: AsyncStream<(any Error, ByteBuffer)> { continuation in
+                self.eventsParseFailureContinuations.append(continuation)
+            }
+        )
+    }
+
     //MARK: Connection data
     public nonisolated let identifyPayload: Gateway.Identify
     
@@ -310,17 +327,15 @@ public actor BotGatewayManager: GatewayManager {
     }
 
     /// Makes an stream of Gateway events.
+    @available(*, deprecated, renamed: "events")
     public func makeEventsStream() -> AsyncStream<Gateway.Event> {
-        AsyncStream<Gateway.Event> { continuation in
-            self.eventsStreamContinuations.append(continuation)
-        }
+        self.events.base
     }
 
     /// Makes an stream of Gateway event parse failures.
+    @available(*, deprecated, renamed: "eventFailures")
     public func makeEventsParseFailureStream() -> AsyncStream<(any Error, ByteBuffer)> {
-        AsyncStream<(any Error, ByteBuffer)> { continuation in
-            self.eventsParseFailureContinuations.append(continuation)
-        }
+        self.eventFailures.base
     }
     
     /// Disconnects from Discord.

commit a949bd53615378cb99a5a2e7960f5179d8714051
Author: Oleksandr <56908314+codemeister64@users.noreply.github.com>
Date:   Sun Sep 24 20:08:44 2023 +0300

    Fix `bot.updatePresence(payload:)` (#57)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 21133eb..0de3065 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -293,11 +293,11 @@ public actor BotGatewayManager: GatewayManager {
     
     /// https://discord.com/developers/docs/topics/gateway-events#update-presence
     public func updatePresence(payload: Gateway.Identify.Presence) {
-        /// This took a lot of time to figure out, not sure why it needs opcode `9` (works with `10` too?!).
+        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
         self.send(payload: .init(
             opcode: .presenceUpdate,
             data: .requestPresenceUpdate(payload)
-        ), opcode: 9)
+        ), opcode: 1)
     }
     
     /// https://discord.com/developers/docs/topics/gateway-events#update-voice-state

commit 08d418ee0f8542dd8fe88d8ef5032a828fd4ad5d
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Thu Jun 1 18:44:42 2023 +0330

    minor refinement

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 7eb0705..21133eb 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -23,7 +23,7 @@ public actor BotGatewayManager: GatewayManager {
         }
     }
     
-    private weak var ws: WebSocket?
+    var ws: WebSocket?
     let eventLoopGroup: any EventLoopGroup
     /// A client to send requests to Discord.
     public nonisolated let client: any DiscordClient

commit f1d0e80098584b34efe611ada5f6d93315295302
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Thu Jun 1 14:21:38 2023 +0330

    minor refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 37bb669..7eb0705 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -14,7 +14,6 @@ public actor BotGatewayManager: GatewayManager {
         var shardConnectedOnceBefore = false
         let shard: IntPair
         let maxConcurrency: Int
-        /// Shard manager must exist if and only if a shard is configured (by the library).
         let shardCoordinator: ShardCoordinator
 
         init(shard: IntPair, maxConcurrency: Int, shardCoordinator: ShardCoordinator) {

commit c252b53d2db3a4a66a3d11d9ac8ddbd09bbd293a
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed May 31 17:34:25 2023 +0330

    minor gateway-manager refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index f943fbc..37bb669 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -92,7 +92,7 @@ public actor BotGatewayManager: GatewayManager {
     internal init(
         eventLoopGroup: any EventLoopGroup,
         client: any DiscordClient,
-        maxFrameSize: Int =  1 << 31,
+        maxFrameSize: Int = 1 << 28,
         shardInfo: ShardInfo,
         identifyPayloadWithShard identifyPayload: Gateway.Identify
     ) {
@@ -114,7 +114,7 @@ public actor BotGatewayManager: GatewayManager {
     public init(
         eventLoopGroup: any EventLoopGroup,
         client: any DiscordClient,
-        maxFrameSize: Int =  1 << 31,
+        maxFrameSize: Int = 1 << 28,
         identifyPayload: Gateway.Identify
     ) {
         self.eventLoopGroup = eventLoopGroup
@@ -146,7 +146,7 @@ public actor BotGatewayManager: GatewayManager {
         eventLoopGroup: any EventLoopGroup,
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
-        maxFrameSize: Int =  1 << 31,
+        maxFrameSize: Int = 1 << 28,
         appId: ApplicationSnowflake? = nil,
         identifyPayload: Gateway.Identify
     ) async {
@@ -180,15 +180,18 @@ public actor BotGatewayManager: GatewayManager {
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
     ///   - token: Your Discord bot-token.
     ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
+    ///   - largeThreshold: Value between 50 and 250, total number of members where the gateway
+    ///     will stop sending offline members in the guild member list.
     ///   - presence: The initial presence of the bot.
     ///   - intents: The Discord intents you want to receive messages for.
     public init(
         eventLoopGroup: any EventLoopGroup,
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
-        maxFrameSize: Int =  1 << 31,
+        maxFrameSize: Int = 1 << 28,
         token: String,
         appId: ApplicationSnowflake? = nil,
+        largeThreshold: Int? = nil,
         presence: Gateway.Identify.Presence? = nil,
         intents: [Gateway.Intent]
     ) async {
@@ -203,9 +206,11 @@ public actor BotGatewayManager: GatewayManager {
         self.maxFrameSize = maxFrameSize
         self.identifyPayload = .init(
             token: token,
+            large_threshold: largeThreshold,
             presence: presence,
             intents: intents
         )
+
         var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
         logger[metadataKey: "gateway-id"] = .string("\(self.id)")
         self.logger = logger

commit c9410a0c446177785296ab893bac8e0030f534d9
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue May 30 22:33:40 2023 +0330

    fix a ws rare bug

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 1299c40..f943fbc 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -245,22 +245,29 @@ public actor BotGatewayManager: GatewayManager {
         logger.trace("Will try to connect to Discord through web-socket")
         do {
             let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
+            let setWebSocket: @Sendable (WebSocket) async -> Void = { ws in
+                await self.closeWebSocket(ws: self.ws)
+                await self.setWebSocket(ws: ws)
+            }
             let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
                 Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
             }
             let onClose: @Sendable (WebSocket) -> Void = { ws in
                 Task { await self.setupOnClose(ws: ws, forConnectionWithId: connectionId) }
             }
-            let ws = try await WebSocket.connect(
+            /// Not removing the returned `WebSocket` for tests compatibility.
+            /// The actual setting of `self.ws` to the new `WebSocket` happens in
+            /// the `setWebSocket` parameter. This is to try to avoid a weird bug where
+            /// `WebSocket.connect()` returns the `WebSocket` _before_ the first event is received.
+            _ = try await WebSocket.connect(
                 to: gatewayURL + queries.makeForURLQuery(),
                 configuration: configuration,
                 on: eventLoopGroup,
+                setWebSocket: setWebSocket,
                 onBuffer: onBuffer,
                 onClose: onClose
             )
             self.logger.debug("Connected to Discord through web-socket. Will configure")
-            self.closeWebSocket(ws: self.ws)
-            self.ws = ws
             self.state.store(.configured, ordering: .relaxed)
         } catch {
             logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
@@ -686,6 +693,10 @@ extension BotGatewayManager {
             logger.trace("Done waiting for other shards")
         }
     }
+
+    func setWebSocket(ws: WebSocket) {
+        self.ws = ws
+    }
     
     private nonisolated func closeWebSocket(ws: WebSocket?) {
         logger.debug("Will possibly close a web-socket")

commit ed67262f4fb377628578d55fa7526d55ed025c61
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue May 30 07:04:51 2023 +0330

    some renames and refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 00c2309..1299c40 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -15,12 +15,12 @@ public actor BotGatewayManager: GatewayManager {
         let shard: IntPair
         let maxConcurrency: Int
         /// Shard manager must exist if and only if a shard is configured (by the library).
-        let shardsCoordinator: ShardsCoordinator
+        let shardCoordinator: ShardCoordinator
 
-        init(shard: IntPair, maxConcurrency: Int, shardsCoordinator: ShardsCoordinator) {
+        init(shard: IntPair, maxConcurrency: Int, shardCoordinator: ShardCoordinator) {
             self.shard = shard
             self.maxConcurrency = maxConcurrency
-            self.shardsCoordinator = shardsCoordinator
+            self.shardCoordinator = shardCoordinator
         }
     }
     
@@ -29,7 +29,7 @@ public actor BotGatewayManager: GatewayManager {
     /// A client to send requests to Discord.
     public nonisolated let client: any DiscordClient
     /// Max frame size we accept to receive through the web-socket connection.
-    nonisolated let maxFrameSize: Int
+    let maxFrameSize: Int
     /// Generator of `BotGatewayManager` ids.
     static let idGenerator = ManagedAtomic(UInt(0))
     /// This gateway manager's identifier.
@@ -129,7 +129,7 @@ public actor BotGatewayManager: GatewayManager {
             var identifyPayload = identifyPayload
             identifyPayload.shard = nil
             self.identifyPayload = identifyPayload
-            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardsGatewayManager' instead.")
+            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardingGatewayManager' instead.")
         } else {
             self.identifyPayload = identifyPayload
         }
@@ -167,7 +167,7 @@ public actor BotGatewayManager: GatewayManager {
             var identifyPayload = identifyPayload
             identifyPayload.shard = nil
             self.identifyPayload = identifyPayload
-            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardsGatewayManager' instead.")
+            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardingGatewayManager' instead.")
         } else {
             self.identifyPayload = identifyPayload
         }
@@ -679,7 +679,7 @@ extension BotGatewayManager {
            !shardInfo.shardConnectedOnceBefore {
             logger.trace("Will wait for other shards")
             /// `shardManager` must exist. Initializer must enforce this.
-            await shardInfo.shardsCoordinator.waitForOtherShards(
+            await shardInfo.shardCoordinator.waitForOtherShards(
                 shard: shardInfo.shard,
                 maxConcurrency: max(shardInfo.maxConcurrency, 1) /// Avoid an unlikely division-by-zero
             )
@@ -697,7 +697,7 @@ extension BotGatewayManager {
     }
 }
 
-// MARK: For ShardsGatewayManager
+// MARK: For ShardingGatewayManager
 extension BotGatewayManager {
     func addEventsContinuation(_ continuation: AsyncStream<Gateway.Event>.Continuation) {
         self.eventsStreamContinuations.append(continuation)

commit 714a05dcf47708df241d800d8492fe330e0e8c51
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue May 30 05:44:37 2023 +0330

    more Gateway refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 9878567..00c2309 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -44,7 +44,7 @@ public actor BotGatewayManager: GatewayManager {
     public nonisolated let identifyPayload: Gateway.Identify
     
     //MARK: Connection state
-    private nonisolated let _state = ManagedAtomic(GatewayState.noConnection)
+    private nonisolated let state = ManagedAtomic(GatewayState.noConnection)
     
     //MARK: Send queue
     
@@ -71,8 +71,10 @@ public actor BotGatewayManager: GatewayManager {
     
     //MARK: Backoff
     
-    /// Discord cares about the identify payload for rate-limiting and if we send
-    /// more than 1000 identifies in a day, Discord will revoke the bot token.
+    /// Discord cares about the identify payload for rate-limiting and if you send
+    /// more than 1000 identifies in a day, Discord will revoke your bot token
+    /// (unless your bot is big enough that has a bigger identify-limit than 1000 per day).
+    ///
     /// This Backoff does not necessarily prevent your bot token getting revoked,
     /// but in the worst case, doesn't let it happen sooner than ~6 hours.
     /// This also helps in other situations, for example when there is a Discord outage.
@@ -210,7 +212,7 @@ public actor BotGatewayManager: GatewayManager {
     }
 
     /// Connects to Discord.
-    /// `_state` must be set to an appropriate value before triggering this function.
+    /// `state` must be set to an appropriate value before triggering this function.
     public func connect() async {
         logger.debug("Connect method triggered")
         /// Guard we're attempting to connect too fast
@@ -221,14 +223,14 @@ public actor BotGatewayManager: GatewayManager {
             try? await Task.sleep(for: connectIn)
         }
         /// Guard if other connections are in process
-        let state = self._state.load(ordering: .relaxed)
+        let state = self.state.load(ordering: .relaxed)
         guard [.noConnection, .configured, .stopped].contains(state) else {
             logger.error("Gateway state doesn't allow a new connection", metadata: [
                 "state": .stringConvertible(state)
             ])
             return
         }
-        self._state.store(.connecting, ordering: .relaxed)
+        self.state.store(.connecting, ordering: .relaxed)
         await self.sendQueue.reset()
         let gatewayURL = await getGatewayURL()
         let queries: [(String, String)] = [
@@ -259,12 +261,12 @@ public actor BotGatewayManager: GatewayManager {
             self.logger.debug("Connected to Discord through web-socket. Will configure")
             self.closeWebSocket(ws: self.ws)
             self.ws = ws
-            self._state.store(.configured, ordering: .relaxed)
+            self.state.store(.configured, ordering: .relaxed)
         } catch {
             logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
                 "error": .string("\(error)")
             ])
-            self._state.store(.noConnection, ordering: .relaxed)
+            self.state.store(.noConnection, ordering: .relaxed)
             await self.connect()
         }
     }
@@ -316,14 +318,14 @@ public actor BotGatewayManager: GatewayManager {
         logger.debug("Will disconnect", metadata: [
             "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
         ])
-        if self._state.load(ordering: .relaxed) == .stopped {
+        if self.state.load(ordering: .relaxed) == .stopped {
             logger.debug("Already disconnected", metadata: [
                 "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
             ])
             return
         }
         self.connectionId.wrappingIncrement(ordering: .relaxed)
-        self._state.store(.stopped, ordering: .relaxed)
+        self.state.store(.stopped, ordering: .relaxed)
         await connectionBackoff.resetTryCount()
         await self.sendQueue.reset()
         self.closeWebSocket(ws: self.ws)
@@ -357,7 +359,7 @@ extension BotGatewayManager {
                 self.resumeGatewayURL = nil
                 self.sessionId = nil
             }
-            self._state.store(.noConnection, ordering: .relaxed)
+            self.state.store(.noConnection, ordering: .relaxed)
             await self.connect()
         case let .hello(hello):
             logger.debug("Received 'hello'")
@@ -494,10 +496,10 @@ extension BotGatewayManager {
                 ]
             )
             if self.canTryReconnect(code: ws.closeCode) {
-                self._state.store(.noConnection, ordering: .relaxed)
+                self.state.store(.noConnection, ordering: .relaxed)
                 await self.connect()
             } else {
-                self._state.store(.stopped, ordering: .relaxed)
+                self.state.store(.stopped, ordering: .relaxed)
                 self.connectionId.wrappingIncrement(ordering: .relaxed)
                 self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/DiscordBM/DiscordBM/issues if you think this is a library issue")
 
@@ -582,7 +584,7 @@ extension BotGatewayManager {
                 logger.debug("Too many unsuccessful pings. Will try to reconnect", metadata: [
                     "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                 ])
-                self._state.store(.noConnection, ordering: .relaxed)
+                self.state.store(.noConnection, ordering: .relaxed)
                 await self.connect()
             }
         }
@@ -651,7 +653,7 @@ extension BotGatewayManager {
                         "Trying to send through ws when a connection is not established",
                         metadata: [
                             "payload": .string("\(payload)"),
-                            "state": .stringConvertible(self._state.load(ordering: .relaxed)),
+                            "state": .stringConvertible(self.state.load(ordering: .relaxed)),
                             "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                         ])
                 }
@@ -660,7 +662,7 @@ extension BotGatewayManager {
     }
     
     private func onSuccessfulConnection() async {
-        self._state.store(.connected, ordering: .relaxed)
+        self.state.store(.connected, ordering: .relaxed)
         await connectionBackoff.resetTryCount()
         self.unsuccessfulPingsCount = 0
         await self.sendQueue.reset()

commit 4ee23faa9c3fce94e5820b9863127f24e34c2772
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon May 29 20:20:09 2023 +0330

    improved shard-ing support

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index b71bf24..9878567 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -4,10 +4,25 @@ import AsyncHTTPClient
 import Atomics
 import Logging
 import DiscordModels
-import enum NIOCore.ChannelError
+import NIO
 import enum NIOWebSocket.WebSocketErrorCode
 
 public actor BotGatewayManager: GatewayManager {
+
+    /// The info related to the shard status of this gateway-manager.
+    struct ShardInfo: Sendable {
+        var shardConnectedOnceBefore = false
+        let shard: IntPair
+        let maxConcurrency: Int
+        /// Shard manager must exist if and only if a shard is configured (by the library).
+        let shardsCoordinator: ShardsCoordinator
+
+        init(shard: IntPair, maxConcurrency: Int, shardsCoordinator: ShardsCoordinator) {
+            self.shard = shard
+            self.maxConcurrency = maxConcurrency
+            self.shardsCoordinator = shardsCoordinator
+        }
+    }
     
     private weak var ws: WebSocket?
     let eventLoopGroup: any EventLoopGroup
@@ -18,23 +33,18 @@ public actor BotGatewayManager: GatewayManager {
     /// Generator of `BotGatewayManager` ids.
     static let idGenerator = ManagedAtomic(UInt(0))
     /// This gateway manager's identifier.
-    public nonisolated let id = BotGatewayManager.idGenerator
-        .wrappingIncrementThenLoad(ordering: .relaxed)
+    public nonisolated let id = idGenerator.wrappingIncrementThenLoad(ordering: .relaxed)
     let logger: Logger
     
     //MARK: Event streams
-    var eventStreamContinuations = [AsyncStream<Gateway.Event>.Continuation]()
-    var eventParseFailureContinuations = [AsyncStream<(any Error, ByteBuffer)>.Continuation]()
+    var eventsStreamContinuations = [AsyncStream<Gateway.Event>.Continuation]()
+    var eventsParseFailureContinuations = [AsyncStream<(any Error, ByteBuffer)>.Continuation]()
     
     //MARK: Connection data
     public nonisolated let identifyPayload: Gateway.Identify
     
     //MARK: Connection state
-    nonisolated let _state = ManagedAtomic(GatewayState.noConnection)
-    /// The current state of the gateway manager.
-    public nonisolated var state: GatewayState {
-        self._state.load(ordering: .relaxed)
-    }
+    private nonisolated let _state = ManagedAtomic(GatewayState.noConnection)
     
     //MARK: Send queue
     
@@ -57,8 +67,7 @@ public actor BotGatewayManager: GatewayManager {
     var resumeGatewayURL: String? = nil
     
     //MARK: Shard-ing
-    var maxConcurrency: Int? = nil
-    var shardConnectedOnceBefore = false
+    var shardInfo: ShardInfo? = nil
     
     //MARK: Backoff
     
@@ -77,13 +86,28 @@ public actor BotGatewayManager: GatewayManager {
     //MARK: Ping-pong tracking properties
     var unsuccessfulPingsCount = 0
     var lastPongDate = Date()
-    
+
+    internal init(
+        eventLoopGroup: any EventLoopGroup,
+        client: any DiscordClient,
+        maxFrameSize: Int =  1 << 31,
+        shardInfo: ShardInfo,
+        identifyPayloadWithShard identifyPayload: Gateway.Identify
+    ) {
+        self.eventLoopGroup = eventLoopGroup
+        self.client = client
+        self.maxFrameSize = maxFrameSize
+        self.shardInfo = shardInfo
+        self.identifyPayload = identifyPayload
+        var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
+        logger[metadataKey: "gateway-id"] = .string("\(self.id)")
+        self.logger = logger
+    }
+
     /// - Parameters:
     ///   - eventLoopGroup: An `EventLoopGroup`.
-    ///   - httpClient: A `HTTPClient`.
     ///   - client: A `DiscordClient` to use.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
-    ///   - appId: Your Discord application id.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
         eventLoopGroup: any EventLoopGroup,
@@ -94,10 +118,19 @@ public actor BotGatewayManager: GatewayManager {
         self.eventLoopGroup = eventLoopGroup
         self.client = client
         self.maxFrameSize = maxFrameSize
-        self.identifyPayload = identifyPayload
+
         var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
         logger[metadataKey: "gateway-id"] = .string("\(self.id)")
         self.logger = logger
+
+        if identifyPayload.shard != nil {
+            var identifyPayload = identifyPayload
+            identifyPayload.shard = nil
+            self.identifyPayload = identifyPayload
+            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardsGatewayManager' instead.")
+        } else {
+            self.identifyPayload = identifyPayload
+        }
     }
     
     /// - Parameters:
@@ -123,10 +156,19 @@ public actor BotGatewayManager: GatewayManager {
             configuration: clientConfiguration
         )
         self.maxFrameSize = maxFrameSize
-        self.identifyPayload = identifyPayload
+
         var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
         logger[metadataKey: "gateway-id"] = .string("\(self.id)")
         self.logger = logger
+
+        if identifyPayload.shard != nil {
+            var identifyPayload = identifyPayload
+            identifyPayload.shard = nil
+            self.identifyPayload = identifyPayload
+            logger.warning("You can't manually configure a 'BotGatewayManager' for shard-ing. Use 'ShardsGatewayManager' instead.")
+        } else {
+            self.identifyPayload = identifyPayload
+        }
     }
     
     /// - Parameters:
@@ -136,7 +178,6 @@ public actor BotGatewayManager: GatewayManager {
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
     ///   - token: Your Discord bot-token.
     ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
-    ///   - shard: What shard this Manager is representing, incase you use shard-ing at all.
     ///   - presence: The initial presence of the bot.
     ///   - intents: The Discord intents you want to receive messages for.
     public init(
@@ -146,7 +187,6 @@ public actor BotGatewayManager: GatewayManager {
         maxFrameSize: Int =  1 << 31,
         token: String,
         appId: ApplicationSnowflake? = nil,
-        shard: IntPair? = nil,
         presence: Gateway.Identify.Presence? = nil,
         intents: [Gateway.Intent]
     ) async {
@@ -161,7 +201,6 @@ public actor BotGatewayManager: GatewayManager {
         self.maxFrameSize = maxFrameSize
         self.identifyPayload = .init(
             token: token,
-            shard: shard,
             presence: presence,
             intents: intents
         )
@@ -179,10 +218,11 @@ public actor BotGatewayManager: GatewayManager {
             logger.warning("Cannot try to connect immediately due to backoff", metadata: [
                 "wait-time": .stringConvertible(connectIn)
             ])
-            await self.sleep(for: connectIn)
+            try? await Task.sleep(for: connectIn)
         }
         /// Guard if other connections are in process
-        guard [.noConnection, .configured, .stopped].contains(self.state) else {
+        let state = self._state.load(ordering: .relaxed)
+        guard [.noConnection, .configured, .stopped].contains(state) else {
             logger.error("Gateway state doesn't allow a new connection", metadata: [
                 "state": .stringConvertible(state)
             ])
@@ -191,8 +231,6 @@ public actor BotGatewayManager: GatewayManager {
         self._state.store(.connecting, ordering: .relaxed)
         await self.sendQueue.reset()
         let gatewayURL = await getGatewayURL()
-        logger.trace("Will wait for other shards if needed")
-        await waitInShardQueueIfNeeded()
         let queries: [(String, String)] = [
             ("v", "\(DiscordGlobalConfiguration.apiVersion)"),
             ("encoding", "json"),
@@ -261,14 +299,14 @@ public actor BotGatewayManager: GatewayManager {
     /// Makes an stream of Gateway events.
     public func makeEventsStream() -> AsyncStream<Gateway.Event> {
         AsyncStream<Gateway.Event> { continuation in
-            self.eventStreamContinuations.append(continuation)
+            self.eventsStreamContinuations.append(continuation)
         }
     }
 
     /// Makes an stream of Gateway event parse failures.
     public func makeEventsParseFailureStream() -> AsyncStream<(any Error, ByteBuffer)> {
         AsyncStream<(any Error, ByteBuffer)> { continuation in
-            self.eventParseFailureContinuations.append(continuation)
+            self.eventsParseFailureContinuations.append(continuation)
         }
     }
     
@@ -289,14 +327,6 @@ public actor BotGatewayManager: GatewayManager {
         await connectionBackoff.resetTryCount()
         await self.sendQueue.reset()
         self.closeWebSocket(ws: self.ws)
-        if let shard = self.identifyPayload.shard,
-           let maxConcurrency = self.maxConcurrency {
-            self.shardConnectedOnceBefore = false
-            await ShardManager.shared.disconnected(
-                shard: shard,
-                maxConcurrency: maxConcurrency
-            )
-        }
     }
 }
 
@@ -331,10 +361,14 @@ extension BotGatewayManager {
             await self.connect()
         case let .hello(hello):
             logger.debug("Received 'hello'")
+            /// Start heart-beating right-away.
+            /// Don't wait for shards first, as that might take too long.
             self.setupPingTask(
                 forConnectionWithId: self.connectionId.load(ordering: .relaxed),
                 every: .milliseconds(Int64(hello.heartbeat_interval))
             )
+            await waitInShardQueueIfNeeded()
+            logger.trace("Will resume or identify")
             await self.sendResumeOrIdentify()
         case let .ready(payload):
             logger.notice("Received ready notice. The connection is fully established", metadata: [
@@ -360,27 +394,14 @@ extension BotGatewayManager {
             logger.trace("Got Discord gateway url from 'resumeGatewayURL'")
             return gatewayURL
         } else {
-            /// If the bot is using shard-ing, we need to call a different endpoint
-            /// to get some more info than only the gateway url.
-            if identifyPayload.shard == nil {
-                if let gatewayURL = try? await client.getGateway().decode().url {
-                    logger.trace("Got Discord gateway url from gateway api call")
-                    return gatewayURL
-                }
+            if let gatewayURL = try? await client.getGateway().decode().url {
+                logger.trace("Got Discord gateway url from gateway api call")
+                return gatewayURL
             } else {
-                if let gatewayBot = try? await client.getBotGateway().decode() {
-                    logger.trace("Got Discord gateway url from gateway-bot api call", metadata: [
-                        "max_concurrency": .stringConvertible(
-                            gatewayBot.session_start_limit.max_concurrency
-                        )
-                    ])
-                    self.maxConcurrency = gatewayBot.session_start_limit.max_concurrency
-                    return gatewayBot.url
-                }
+                logger.error("Cannot get gateway url to connect to. Will retry in 10 seconds")
+                try? await Task.sleep(for: .seconds(10))
+                return await self.getGatewayURL()
             }
-            logger.error("Cannot get gateway url to connect to. Will retry in 10 seconds")
-            await self.sleep(for: .seconds(10))
-            return await self.getGatewayURL()
         }
     }
     
@@ -443,14 +464,14 @@ extension BotGatewayManager {
                 "event": .string("\(event)")
             ])
             Task { await self.processEvent(event) }
-            for continuation in self.eventStreamContinuations {
+            for continuation in self.eventsStreamContinuations {
                 continuation.yield(event)
             }
         } catch {
             self.logger.debug("Failed to decode event", metadata: [
                 "error": .string("\(error)")
             ])
-            for continuation in self.eventParseFailureContinuations {
+            for continuation in self.eventsParseFailureContinuations {
                 continuation.yield((error, buffer))
             }
         }
@@ -521,7 +542,7 @@ extension BotGatewayManager {
         every duration: Duration
     ) {
         Task {
-            await self.sleep(for: duration)
+            try? await Task.sleep(for: duration)
             guard self.connectionId.load(ordering: .relaxed) == connectionId else {
                 self.logger.trace("Canceled a ping task", metadata: [
                     "connectionId": .stringConvertible(connectionId)
@@ -545,7 +566,7 @@ extension BotGatewayManager {
             data: .heartbeat(lastSequenceNumber: self.sequenceNumber)
         ))
         Task {
-            await self.sleep(for: .seconds(10))
+            try? await Task.sleep(for: .seconds(10))
             guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
             /// 15 == 10 + 5. 10 seconds that we slept, + 5 seconds tolerance.
             /// The tolerance being too long should not matter as pings usually happen
@@ -643,34 +664,24 @@ extension BotGatewayManager {
         await connectionBackoff.resetTryCount()
         self.unsuccessfulPingsCount = 0
         await self.sendQueue.reset()
-        if let shard = self.identifyPayload.shard,
-           let maxConcurrency = self.maxConcurrency,
-           !self.shardConnectedOnceBefore {
-            self.shardConnectedOnceBefore = true
-            await ShardManager.shared.connected(
-                shard: shard,
-                maxConcurrency: maxConcurrency
-            )
-        }
     }
 
     /// Discord says: "you must start the shard buckets in "order". That means that you can start shard 0 -> shard 15 concurrently, and then you can start shard 16 -> shard 31."
     /// https://discord.com/developers/docs/topics/gateway#sharding
     ///
-    /// This shard-ing logic can't handle out-of-process shards.
+    /// This shard-ing logic can't handle out-of-process shards yet.
+    /// Maybe soon with some `DistributedActor`s magic.
     private func waitInShardQueueIfNeeded() async {
-        if let shard = self.identifyPayload.shard,
-           let maxConcurrency,
+        if let shardInfo,
            /// If shard already connected once before, then skip the wait.
-           !self.shardConnectedOnceBefore {
-            await ShardManager.shared.waitForOtherShards(
-                shard: shard,
-                maxConcurrency: max(maxConcurrency, 1) /// Avoid an unlikely division-by-zero
+           !shardInfo.shardConnectedOnceBefore {
+            logger.trace("Will wait for other shards")
+            /// `shardManager` must exist. Initializer must enforce this.
+            await shardInfo.shardsCoordinator.waitForOtherShards(
+                shard: shardInfo.shard,
+                maxConcurrency: max(shardInfo.maxConcurrency, 1) /// Avoid an unlikely division-by-zero
             )
-            /// Wait a little bit more.
-            /// Nothing scientific but seems to make Discord happy `\_()_/`.
-            let more = (shard.second / maxConcurrency) * 500
-            await self.sleep(for: .milliseconds(more))
+            logger.trace("Done waiting for other shards")
         }
     }
     
@@ -682,14 +693,36 @@ extension BotGatewayManager {
             ])
         }
     }
-    
-    private func sleep(for duration: Duration) async {
-        do {
-            try await Task.sleep(for: duration)
-        } catch {
-            logger.warning("Task failed to sleep properly", metadata: [
-                "error": .string("\(error)")
-            ])
+}
+
+// MARK: For ShardsGatewayManager
+extension BotGatewayManager {
+    func addEventsContinuation(_ continuation: AsyncStream<Gateway.Event>.Continuation) {
+        self.eventsStreamContinuations.append(continuation)
+    }
+
+    func addEventsParseFailureContinuation(
+        _ continuation: AsyncStream<(any Error, ByteBuffer)>.Continuation
+    ) {
+        self.eventsParseFailureContinuations.append(continuation)
+    }
+}
+
+//MARK: - GatewayState
+private enum GatewayState: Int, Sendable, AtomicValue, CustomStringConvertible {
+    case stopped
+    case noConnection
+    case connecting
+    case configured
+    case connected
+
+    var description: String {
+        switch self {
+        case .stopped: return "stopped"
+        case .noConnection: return "noConnection"
+        case .connecting: return "connecting"
+        case .configured: return "configured"
+        case .connected: return "connected"
         }
     }
 }

commit a31d6631ba72314d66b2451fee16157926fd8945
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sun May 28 17:06:33 2023 +0330

    revert back `GatewayManager.connect()` to be isolated

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 7975889..b71bf24 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -170,11 +170,65 @@ public actor BotGatewayManager: GatewayManager {
         self.logger = logger
     }
 
-    /// Starts connecting to Discord.
-    /// If you want to become aware of when the connection is established, you need
-    /// to listen for the related Gateway events such as 'ready' and 'resume'.
-    public nonisolated func connect() {
-        Task { await self._connect() }
+    /// Connects to Discord.
+    /// `_state` must be set to an appropriate value before triggering this function.
+    public func connect() async {
+        logger.debug("Connect method triggered")
+        /// Guard we're attempting to connect too fast
+        if let connectIn = await connectionBackoff.canPerformIn() {
+            logger.warning("Cannot try to connect immediately due to backoff", metadata: [
+                "wait-time": .stringConvertible(connectIn)
+            ])
+            await self.sleep(for: connectIn)
+        }
+        /// Guard if other connections are in process
+        guard [.noConnection, .configured, .stopped].contains(self.state) else {
+            logger.error("Gateway state doesn't allow a new connection", metadata: [
+                "state": .stringConvertible(state)
+            ])
+            return
+        }
+        self._state.store(.connecting, ordering: .relaxed)
+        await self.sendQueue.reset()
+        let gatewayURL = await getGatewayURL()
+        logger.trace("Will wait for other shards if needed")
+        await waitInShardQueueIfNeeded()
+        let queries: [(String, String)] = [
+            ("v", "\(DiscordGlobalConfiguration.apiVersion)"),
+            ("encoding", "json"),
+            ("compress", "zlib-stream")
+        ]
+        let configuration = WebSocketClient.Configuration(
+            maxFrameSize: self.maxFrameSize,
+            decompression: .enabled
+        )
+        logger.trace("Will try to connect to Discord through web-socket")
+        do {
+            let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
+            let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
+                Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
+            }
+            let onClose: @Sendable (WebSocket) -> Void = { ws in
+                Task { await self.setupOnClose(ws: ws, forConnectionWithId: connectionId) }
+            }
+            let ws = try await WebSocket.connect(
+                to: gatewayURL + queries.makeForURLQuery(),
+                configuration: configuration,
+                on: eventLoopGroup,
+                onBuffer: onBuffer,
+                onClose: onClose
+            )
+            self.logger.debug("Connected to Discord through web-socket. Will configure")
+            self.closeWebSocket(ws: self.ws)
+            self.ws = ws
+            self._state.store(.configured, ordering: .relaxed)
+        } catch {
+            logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
+                "error": .string("\(error)")
+            ])
+            self._state.store(.noConnection, ordering: .relaxed)
+            await self.connect()
+        }
     }
 
     /// https://discord.com/developers/docs/topics/gateway-events#request-guild-members
@@ -247,67 +301,6 @@ public actor BotGatewayManager: GatewayManager {
 }
 
 extension BotGatewayManager {
-    /// Starts connecting to Discord.
-    /// `_state` must be set to an appropriate value before triggering this function.
-    func _connect() async {
-        logger.debug("Connect method triggered")
-        /// Guard we're attempting to connect too fast
-        if let connectIn = await connectionBackoff.canPerformIn() {
-            logger.warning("Cannot try to connect immediately due to backoff", metadata: [
-                "wait-time": .stringConvertible(connectIn)
-            ])
-            await self.sleep(for: connectIn)
-        }
-        /// Guard if other connections are in process
-        guard [.noConnection, .configured, .stopped].contains(self.state) else {
-            logger.error("Gateway state doesn't allow a new connection", metadata: [
-                "state": .stringConvertible(state)
-            ])
-            return
-        }
-        self._state.store(.connecting, ordering: .relaxed)
-        await self.sendQueue.reset()
-        let gatewayURL = await getGatewayURL()
-        logger.trace("Will wait for other shards if needed")
-        await waitInShardQueueIfNeeded()
-        let queries: [(String, String)] = [
-            ("v", "\(DiscordGlobalConfiguration.apiVersion)"),
-            ("encoding", "json"),
-            ("compress", "zlib-stream")
-        ]
-        let configuration = WebSocketClient.Configuration(
-            maxFrameSize: self.maxFrameSize,
-            decompression: .enabled
-        )
-        logger.trace("Will try to connect to Discord through web-socket")
-        do {
-            let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
-            let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
-                Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
-            }
-            let onClose: @Sendable (WebSocket) -> Void = { ws in
-                Task { await self.setupOnClose(ws: ws, forConnectionWithId: connectionId) }
-            }
-            let ws = try await WebSocket.connect(
-                to: gatewayURL + queries.makeForURLQuery(),
-                configuration: configuration,
-                on: eventLoopGroup,
-                onBuffer: onBuffer,
-                onClose: onClose
-            )
-            self.logger.debug("Connected to Discord through web-socket. Will configure")
-            self.closeWebSocket(ws: self.ws)
-            self.ws = ws
-            self._state.store(.configured, ordering: .relaxed)
-        } catch {
-            logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
-                "error": .string("\(error)")
-            ])
-            self._state.store(.noConnection, ordering: .relaxed)
-            await self._connect()
-        }
-    }
-
     private func processEvent(_ event: Gateway.Event) async {
         if let sequenceNumber = event.sequenceNumber {
             self.sequenceNumber = sequenceNumber
@@ -335,7 +328,7 @@ extension BotGatewayManager {
                 self.sessionId = nil
             }
             self._state.store(.noConnection, ordering: .relaxed)
-            await self._connect()
+            await self.connect()
         case let .hello(hello):
             logger.debug("Received 'hello'")
             self.setupPingTask(
@@ -481,7 +474,7 @@ extension BotGatewayManager {
             )
             if self.canTryReconnect(code: ws.closeCode) {
                 self._state.store(.noConnection, ordering: .relaxed)
-                await self._connect()
+                await self.connect()
             } else {
                 self._state.store(.stopped, ordering: .relaxed)
                 self.connectionId.wrappingIncrement(ordering: .relaxed)
@@ -569,7 +562,7 @@ extension BotGatewayManager {
                     "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                 ])
                 self._state.store(.noConnection, ordering: .relaxed)
-                await self._connect()
+                await self.connect()
             }
         }
     }
@@ -617,7 +610,7 @@ extension BotGatewayManager {
                            case .ioOnClosedChannel = channelError {
                             self.logger.error("Received 'ChannelError.ioOnClosedChannel' error while sending payload through web-socket. Will fully disconnect and reconnect again")
                             await self.disconnect()
-                            await self._connect()
+                            await self.connect()
                         } else {
                             self.logger.error("Could not send payload through web-socket", metadata: [
                                 "error": .string("\(error)"),

commit a2561ab23460aedc6c3cceb358ab676fa47fefc5
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sun May 28 01:52:28 2023 +0330

    update links

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index b7fd896..7975889 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -485,7 +485,7 @@ extension BotGatewayManager {
             } else {
                 self._state.store(.stopped, ordering: .relaxed)
                 self.connectionId.wrappingIncrement(ordering: .relaxed)
-                self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/MahdiBM/DiscordBM/issues if you think this is a library issue")
+                self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/DiscordBM/DiscordBM/issues if you think this is a library issue")
 
                 /// Don't remove/end the event streams just to stop apps from crashing/restarting
                 /// which could result in bot-token revocations or even temporary ip bans.

commit d454ba061fa6c96f9cd312f9e9f12501116a6aab
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 26 20:48:13 2023 +0330

    add `LooseEndpoint` for direct download from CDN

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 0a7e20a..b7fd896 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -4,6 +4,7 @@ import AsyncHTTPClient
 import Atomics
 import Logging
 import DiscordModels
+import enum NIOCore.ChannelError
 import enum NIOWebSocket.WebSocketErrorCode
 
 public actor BotGatewayManager: GatewayManager {
@@ -612,12 +613,19 @@ extension BotGatewayManager {
                             opcode: .init(encodedWebSocketOpcode: opcode)!
                         )
                     } catch {
-                        self.logger.error("Could not send payload through websocket", metadata: [
-                            "error": .string("\(error)"),
-                            "payload": .string("\(payload)"),
-                            "opcode": .stringConvertible(opcode),
-                            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                        ])
+                        if let channelError = error as? ChannelError,
+                           case .ioOnClosedChannel = channelError {
+                            self.logger.error("Received 'ChannelError.ioOnClosedChannel' error while sending payload through web-socket. Will fully disconnect and reconnect again")
+                            await self.disconnect()
+                            await self._connect()
+                        } else {
+                            self.logger.error("Could not send payload through web-socket", metadata: [
+                                "error": .string("\(error)"),
+                                "payload": .string("\(payload)"),
+                                "opcode": .stringConvertible(opcode),
+                                "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                            ])
+                        }
                     }
                 } else {
                     /// Pings aka `heartbeat`s are fine if they are sent when a ws connection

commit 2bd64d102c36986ec19dc88ea4c20ea883857934
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 26 13:40:15 2023 +0330

    better `DiscordHTTPErrorResponse` + remove option for `BotGatewayManager` no-compression

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index fbeffae..0a7e20a 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -59,9 +59,6 @@ public actor BotGatewayManager: GatewayManager {
     var maxConcurrency: Int? = nil
     var shardConnectedOnceBefore = false
     
-    //MARK: Compression
-    let compression: Bool
-    
     //MARK: Backoff
     
     /// Discord cares about the identify payload for rate-limiting and if we send
@@ -85,20 +82,17 @@ public actor BotGatewayManager: GatewayManager {
     ///   - httpClient: A `HTTPClient`.
     ///   - client: A `DiscordClient` to use.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
-    ///   - compression: Enables transport compression for less network bandwidth usage.
     ///   - appId: Your Discord application id.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
         eventLoopGroup: any EventLoopGroup,
         client: any DiscordClient,
         maxFrameSize: Int =  1 << 31,
-        compression: Bool = true,
         identifyPayload: Gateway.Identify
     ) {
         self.eventLoopGroup = eventLoopGroup
         self.client = client
         self.maxFrameSize = maxFrameSize
-        self.compression = compression
         self.identifyPayload = identifyPayload
         var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
         logger[metadataKey: "gateway-id"] = .string("\(self.id)")
@@ -110,7 +104,6 @@ public actor BotGatewayManager: GatewayManager {
     ///   - httpClient: A `HTTPClient`.
     ///   - clientConfiguration: Configuration of the `DiscordClient`.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
-    ///   - compression: Enables transport compression for less network bandwidth usage.
     ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
@@ -118,7 +111,6 @@ public actor BotGatewayManager: GatewayManager {
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int =  1 << 31,
-        compression: Bool = true,
         appId: ApplicationSnowflake? = nil,
         identifyPayload: Gateway.Identify
     ) async {
@@ -130,7 +122,6 @@ public actor BotGatewayManager: GatewayManager {
             configuration: clientConfiguration
         )
         self.maxFrameSize = maxFrameSize
-        self.compression = compression
         self.identifyPayload = identifyPayload
         var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
         logger[metadataKey: "gateway-id"] = .string("\(self.id)")
@@ -142,7 +133,6 @@ public actor BotGatewayManager: GatewayManager {
     ///   - httpClient: A `HTTPClient`.
     ///   - clientConfiguration: Configuration of the `DiscordClient`.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
-    ///   - compression: Enables transport compression for less network bandwidth usage.
     ///   - token: Your Discord bot-token.
     ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
     ///   - shard: What shard this Manager is representing, incase you use shard-ing at all.
@@ -153,7 +143,6 @@ public actor BotGatewayManager: GatewayManager {
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int =  1 << 31,
-        compression: Bool = true,
         token: String,
         appId: ApplicationSnowflake? = nil,
         shard: IntPair? = nil,
@@ -169,7 +158,6 @@ public actor BotGatewayManager: GatewayManager {
             configuration: clientConfiguration
         )
         self.maxFrameSize = maxFrameSize
-        self.compression = compression
         self.identifyPayload = .init(
             token: token,
             shard: shard,
@@ -181,68 +169,13 @@ public actor BotGatewayManager: GatewayManager {
         self.logger = logger
     }
 
+    /// Starts connecting to Discord.
+    /// If you want to become aware of when the connection is established, you need
+    /// to listen for the related Gateway events such as 'ready' and 'resume'.
     public nonisolated func connect() {
-        Task { self._connect }
+        Task { await self._connect() }
     }
 
-    /// Starts connecting to Discord.
-    /// `_state` must be set to an appropriate value before triggering this function.
-    func _connect() async {
-        logger.debug("Connect method triggered")
-        /// Guard we're attempting to connect too fast
-        if let connectIn = await connectionBackoff.canPerformIn() {
-            logger.warning("Cannot try to connect immediately due to backoff", metadata: [
-                "wait-time": .stringConvertible(connectIn)
-            ])
-            await self.sleep(for: connectIn)
-        }
-        /// Guard if other connections are in process
-        guard [.noConnection, .configured, .stopped].contains(self.state) else {
-            logger.error("Gateway state doesn't allow a new connection", metadata: [
-                "state": .stringConvertible(state)
-            ])
-            return
-        }
-        self._state.store(.connecting, ordering: .relaxed)
-        await self.sendQueue.reset()
-        let gatewayURL = await getGatewayURL()
-        var urlSuffix = "?v=\(DiscordGlobalConfiguration.apiVersion)&encoding=json"
-        logger.trace("Will wait for other shards if needed")
-        await waitInShardQueueIfNeeded()
-        var configuration = WebSocketClient.Configuration(maxFrameSize: self.maxFrameSize)
-        if compression {
-            urlSuffix += "&compress=zlib-stream"
-            configuration.decompression = .enabled
-        }
-        logger.trace("Will try to connect to Discord through web-socket")
-        do {
-            let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
-            let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
-                Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
-            }
-            let onClose: @Sendable (WebSocket) -> Void = { ws in
-                Task { await self.setupOnClose(ws: ws, forConnectionWithId: connectionId) }
-            }
-            let ws = try await WebSocket.connect(
-                to: gatewayURL + urlSuffix,
-                configuration: configuration,
-                on: eventLoopGroup,
-                onBuffer: onBuffer,
-                onClose: onClose
-            )
-            self.logger.debug("Connected to Discord through web-socket. Will configure")
-            self.closeWebSocket(ws: self.ws)
-            self.ws = ws
-            self._state.store(.configured, ordering: .relaxed)
-        } catch {
-            logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
-                "error": .string("\(error)")
-            ])
-            self._state.store(.noConnection, ordering: .relaxed)
-            await self._connect()
-        }
-    }
-    
     /// https://discord.com/developers/docs/topics/gateway-events#request-guild-members
     public func requestGuildMembersChunk(payload: Gateway.RequestGuildMembers) {
         /// This took a lot of time to figure out, not sure why it needs opcode `1`.
@@ -313,6 +246,67 @@ public actor BotGatewayManager: GatewayManager {
 }
 
 extension BotGatewayManager {
+    /// Starts connecting to Discord.
+    /// `_state` must be set to an appropriate value before triggering this function.
+    func _connect() async {
+        logger.debug("Connect method triggered")
+        /// Guard we're attempting to connect too fast
+        if let connectIn = await connectionBackoff.canPerformIn() {
+            logger.warning("Cannot try to connect immediately due to backoff", metadata: [
+                "wait-time": .stringConvertible(connectIn)
+            ])
+            await self.sleep(for: connectIn)
+        }
+        /// Guard if other connections are in process
+        guard [.noConnection, .configured, .stopped].contains(self.state) else {
+            logger.error("Gateway state doesn't allow a new connection", metadata: [
+                "state": .stringConvertible(state)
+            ])
+            return
+        }
+        self._state.store(.connecting, ordering: .relaxed)
+        await self.sendQueue.reset()
+        let gatewayURL = await getGatewayURL()
+        logger.trace("Will wait for other shards if needed")
+        await waitInShardQueueIfNeeded()
+        let queries: [(String, String)] = [
+            ("v", "\(DiscordGlobalConfiguration.apiVersion)"),
+            ("encoding", "json"),
+            ("compress", "zlib-stream")
+        ]
+        let configuration = WebSocketClient.Configuration(
+            maxFrameSize: self.maxFrameSize,
+            decompression: .enabled
+        )
+        logger.trace("Will try to connect to Discord through web-socket")
+        do {
+            let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
+            let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
+                Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
+            }
+            let onClose: @Sendable (WebSocket) -> Void = { ws in
+                Task { await self.setupOnClose(ws: ws, forConnectionWithId: connectionId) }
+            }
+            let ws = try await WebSocket.connect(
+                to: gatewayURL + queries.makeForURLQuery(),
+                configuration: configuration,
+                on: eventLoopGroup,
+                onBuffer: onBuffer,
+                onClose: onClose
+            )
+            self.logger.debug("Connected to Discord through web-socket. Will configure")
+            self.closeWebSocket(ws: self.ws)
+            self.ws = ws
+            self._state.store(.configured, ordering: .relaxed)
+        } catch {
+            logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
+                "error": .string("\(error)")
+            ])
+            self._state.store(.noConnection, ordering: .relaxed)
+            await self._connect()
+        }
+    }
+
     private func processEvent(_ event: Gateway.Event) async {
         if let sequenceNumber = event.sequenceNumber {
             self.sequenceNumber = sequenceNumber

commit 70d6f83c72f2df3e219e212a65c84789216c560b
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 26 12:59:30 2023 +0330

    `GatewayManager.connect()` -> nonisolated

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index e733646..fbeffae 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -180,10 +180,14 @@ public actor BotGatewayManager: GatewayManager {
         logger[metadataKey: "gateway-id"] = .string("\(self.id)")
         self.logger = logger
     }
-    
+
+    public nonisolated func connect() {
+        Task { self._connect }
+    }
+
     /// Starts connecting to Discord.
     /// `_state` must be set to an appropriate value before triggering this function.
-    public func connect() async {
+    func _connect() async {
         logger.debug("Connect method triggered")
         /// Guard we're attempting to connect too fast
         if let connectIn = await connectionBackoff.canPerformIn() {
@@ -235,7 +239,7 @@ public actor BotGatewayManager: GatewayManager {
                 "error": .string("\(error)")
             ])
             self._state.store(.noConnection, ordering: .relaxed)
-            await self.connect()
+            await self._connect()
         }
     }
     
@@ -336,7 +340,7 @@ extension BotGatewayManager {
                 self.sessionId = nil
             }
             self._state.store(.noConnection, ordering: .relaxed)
-            await self.connect()
+            await self._connect()
         case let .hello(hello):
             logger.debug("Received 'hello'")
             self.setupPingTask(
@@ -482,7 +486,7 @@ extension BotGatewayManager {
             )
             if self.canTryReconnect(code: ws.closeCode) {
                 self._state.store(.noConnection, ordering: .relaxed)
-                await self.connect()
+                await self._connect()
             } else {
                 self._state.store(.stopped, ordering: .relaxed)
                 self.connectionId.wrappingIncrement(ordering: .relaxed)
@@ -570,7 +574,7 @@ extension BotGatewayManager {
                     "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
                 ])
                 self._state.store(.noConnection, ordering: .relaxed)
-                await self.connect()
+                await self._connect()
             }
         }
     }

commit c0ada946e797cf3e1581a5d18504e5026b6c6db8
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon May 22 16:15:58 2023 +0330

    more ExistentialAny

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 28a4359..e733646 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -89,7 +89,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - appId: Your Discord application id.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
-        eventLoopGroup: EventLoopGroup,
+        eventLoopGroup: any EventLoopGroup,
         client: any DiscordClient,
         maxFrameSize: Int =  1 << 31,
         compression: Bool = true,
@@ -114,7 +114,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
-        eventLoopGroup: EventLoopGroup,
+        eventLoopGroup: any EventLoopGroup,
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int =  1 << 31,

commit eca7f323b182721332535adcfeb5717d514b2091
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon May 22 15:56:10 2023 +0330

    more ExistentialAny s

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 68774fa..28a4359 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -149,7 +149,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - presence: The initial presence of the bot.
     ///   - intents: The Discord intents you want to receive messages for.
     public init(
-        eventLoopGroup: EventLoopGroup,
+        eventLoopGroup: any EventLoopGroup,
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int =  1 << 31,

commit cabe56e734ba1834651639f4be1113b03c9f79ef
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon May 22 15:25:46 2023 +0330

    README update + add `upcoming-feature` flags

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 74be8ae..68774fa 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -23,7 +23,7 @@ public actor BotGatewayManager: GatewayManager {
     
     //MARK: Event streams
     var eventStreamContinuations = [AsyncStream<Gateway.Event>.Continuation]()
-    var eventParseFailureContinuations = [AsyncStream<(Error, ByteBuffer)>.Continuation]()
+    var eventParseFailureContinuations = [AsyncStream<(any Error, ByteBuffer)>.Continuation]()
     
     //MARK: Connection data
     public nonisolated let identifyPayload: Gateway.Identify
@@ -274,8 +274,8 @@ public actor BotGatewayManager: GatewayManager {
     }
 
     /// Makes an stream of Gateway event parse failures.
-    public func makeEventsParseFailureStream() -> AsyncStream<(Error, ByteBuffer)> {
-        AsyncStream<(Error, ByteBuffer)> { continuation in
+    public func makeEventsParseFailureStream() -> AsyncStream<(any Error, ByteBuffer)> {
+        AsyncStream<(any Error, ByteBuffer)> { continuation in
             self.eventParseFailureContinuations.append(continuation)
         }
     }

commit 7af2903fb77f3b212bd1c29e4200aa5f25dafc93
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sat May 20 14:24:28 2023 +0330

    decrease need of manually providing an app-id

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 34988f5..74be8ae 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -111,7 +111,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - clientConfiguration: Configuration of the `DiscordClient`.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
     ///   - compression: Enables transport compression for less network bandwidth usage.
-    ///   - appId: Your Discord application id.
+    ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
         eventLoopGroup: EventLoopGroup,
@@ -144,7 +144,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
     ///   - compression: Enables transport compression for less network bandwidth usage.
     ///   - token: Your Discord bot-token.
-    ///   - appId: Your Discord application id.
+    ///   - appId: Your Discord application-id. If not provided, it'll be extracted from bot-token.
     ///   - shard: What shard this Manager is representing, incase you use shard-ing at all.
     ///   - presence: The initial presence of the bot.
     ///   - intents: The Discord intents you want to receive messages for.

commit 75912d164da22f54bf5ce31053f8da4f566cf895
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue May 16 12:05:48 2023 +0330

    test fixes

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 054baf3..34988f5 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -158,7 +158,7 @@ public actor BotGatewayManager: GatewayManager {
         appId: ApplicationSnowflake? = nil,
         shard: IntPair? = nil,
         presence: Gateway.Identify.Presence? = nil,
-        intents: [Gateway.Intent] = []
+        intents: [Gateway.Intent]
     ) async {
         let token = Secret(token)
         self.eventLoopGroup = eventLoopGroup

commit 8cc19e789861d9201debab392c72a9e191401c3e
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon May 15 23:09:56 2023 +0330

    `GatewayManager` require `var identifyPayload`

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 8545c86..054baf3 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -26,7 +26,7 @@ public actor BotGatewayManager: GatewayManager {
     var eventParseFailureContinuations = [AsyncStream<(Error, ByteBuffer)>.Continuation]()
     
     //MARK: Connection data
-    nonisolated let identifyPayload: Gateway.Identify
+    public nonisolated let identifyPayload: Gateway.Identify
     
     //MARK: Connection state
     nonisolated let _state = ManagedAtomic(GatewayState.noConnection)

commit 85722ad6019c4e676b453e83e1876c72a0bdd68f
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon May 15 22:01:54 2023 +0330

    Full endpoints support (#49)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 4a0f918..8545c86 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -662,12 +662,11 @@ extension BotGatewayManager {
     private func waitInShardQueueIfNeeded() async {
         if let shard = self.identifyPayload.shard,
            let maxConcurrency,
-           /// Just to mitigate a possible crash, otherwise shouldn't happen at all.
-           maxConcurrency != 0,
+           /// If shard already connected once before, then skip the wait.
            !self.shardConnectedOnceBefore {
             await ShardManager.shared.waitForOtherShards(
                 shard: shard,
-                maxConcurrency: maxConcurrency
+                maxConcurrency: max(maxConcurrency, 1) /// Avoid an unlikely division-by-zero
             )
             /// Wait a little bit more.
             /// Nothing scientific but seems to make Discord happy `\_()_/`.

commit c260b26696d23c3fa73799810f5342b61d09d14e
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed May 10 15:10:28 2023 +0330

    Fix/Stabilize some tests + make BotGatewayManager/DefaultDiscordClient inits async

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index b4c95a5..4a0f918 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -56,8 +56,8 @@ public actor BotGatewayManager: GatewayManager {
     var resumeGatewayURL: String? = nil
     
     //MARK: Shard-ing
-    private static let shardManager = ShardManager()
     var maxConcurrency: Int? = nil
+    var shardConnectedOnceBefore = false
     
     //MARK: Compression
     let compression: Bool
@@ -110,8 +110,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - httpClient: A `HTTPClient`.
     ///   - clientConfiguration: Configuration of the `DiscordClient`.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
-    ///   - compression: Enables transport compression for less network bandwidth usage
-    ///    but more CPU load.
+    ///   - compression: Enables transport compression for less network bandwidth usage.
     ///   - appId: Your Discord application id.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
@@ -122,9 +121,9 @@ public actor BotGatewayManager: GatewayManager {
         compression: Bool = true,
         appId: ApplicationSnowflake? = nil,
         identifyPayload: Gateway.Identify
-    ) {
+    ) async {
         self.eventLoopGroup = eventLoopGroup
-        self.client = DefaultDiscordClient(
+        self.client = await DefaultDiscordClient(
             httpClient: httpClient,
             token: identifyPayload.token,
             appId: appId,
@@ -143,8 +142,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - httpClient: A `HTTPClient`.
     ///   - clientConfiguration: Configuration of the `DiscordClient`.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
-    ///   - compression: Enables transport compression for less network bandwidth usage
-    ///    but more CPU load.
+    ///   - compression: Enables transport compression for less network bandwidth usage.
     ///   - token: Your Discord bot-token.
     ///   - appId: Your Discord application id.
     ///   - shard: What shard this Manager is representing, incase you use shard-ing at all.
@@ -161,10 +159,10 @@ public actor BotGatewayManager: GatewayManager {
         shard: IntPair? = nil,
         presence: Gateway.Identify.Presence? = nil,
         intents: [Gateway.Intent] = []
-    ) {
+    ) async {
         let token = Secret(token)
         self.eventLoopGroup = eventLoopGroup
-        self.client = DefaultDiscordClient(
+        self.client = await DefaultDiscordClient(
             httpClient: httpClient,
             token: token,
             appId: appId,
@@ -299,6 +297,14 @@ public actor BotGatewayManager: GatewayManager {
         await connectionBackoff.resetTryCount()
         await self.sendQueue.reset()
         self.closeWebSocket(ws: self.ws)
+        if let shard = self.identifyPayload.shard,
+           let maxConcurrency = self.maxConcurrency {
+            self.shardConnectedOnceBefore = false
+            await ShardManager.shared.disconnected(
+                shard: shard,
+                maxConcurrency: maxConcurrency
+            )
+        }
     }
 }
 
@@ -639,8 +645,13 @@ extension BotGatewayManager {
         self.unsuccessfulPingsCount = 0
         await self.sendQueue.reset()
         if let shard = self.identifyPayload.shard,
-           let maxConcurrency = self.maxConcurrency {
-            await Self.shardManager.connected(shard: shard, maxConcurrency: maxConcurrency)
+           let maxConcurrency = self.maxConcurrency,
+           !self.shardConnectedOnceBefore {
+            self.shardConnectedOnceBefore = true
+            await ShardManager.shared.connected(
+                shard: shard,
+                maxConcurrency: maxConcurrency
+            )
         }
     }
 
@@ -650,24 +661,27 @@ extension BotGatewayManager {
     /// This shard-ing logic can't handle out-of-process shards.
     private func waitInShardQueueIfNeeded() async {
         if let shard = self.identifyPayload.shard,
-           let maxConcurrency {
-            await Self.shardManager.waitForOtherShards(shard: shard, maxConcurrency: maxConcurrency)
-            /// Wait a little bit more. Nothing scientific but seems to make Discord happy `\_()_/`.
-            let more = (shard.second / maxConcurrency) * 250
+           let maxConcurrency,
+           /// Just to mitigate a possible crash, otherwise shouldn't happen at all.
+           maxConcurrency != 0,
+           !self.shardConnectedOnceBefore {
+            await ShardManager.shared.waitForOtherShards(
+                shard: shard,
+                maxConcurrency: maxConcurrency
+            )
+            /// Wait a little bit more.
+            /// Nothing scientific but seems to make Discord happy `\_()_/`.
+            let more = (shard.second / maxConcurrency) * 500
             await self.sleep(for: .milliseconds(more))
         }
     }
     
     private nonisolated func closeWebSocket(ws: WebSocket?) {
         logger.debug("Will possibly close a web-socket")
-        Task {
-            do {
-                try await ws?.close()
-            } catch {
-                self.logger.warning("Connection close error", metadata: [
-                    "error": .string("\(error)")
-                ])
-            }
+        ws?.closeWithFuture().whenFailure { error in
+            self.logger.warning("Couldn't close a web-socket properly", metadata: [
+                "error": .string("\(error)")
+            ])
         }
     }
     
@@ -681,44 +695,3 @@ extension BotGatewayManager {
         }
     }
 }
-
-private actor ShardManager {
-    /// [BucketIndex: Continuations]
-    var waiters = [Int: [CheckedContinuation<Void, Never>]]()
-    var connectedShards = Set<Int>()
-
-    func waitForOtherShards(shard: IntPair, maxConcurrency: Int) async {
-        let bucketIndex = shard.first / maxConcurrency
-        if bucketIndex == 0 {
-            return
-        } else {
-            /// If other shards are already connected, return immediately.
-            let lastBucketIndex = bucketIndex - 1
-            let start = lastBucketIndex * maxConcurrency
-            let end = start + maxConcurrency
-            let inBuckets = start..<end
-            if inBuckets.allSatisfy({ self.connectedShards.contains($0) }) {
-                return
-            } else {
-                /// If other shards are **not** already connected, wait.
-                await withCheckedContinuation {
-                    self.waiters[bucketIndex, default: []].append($0)
-                }
-            }
-        }
-    }
-
-    func connected(shard: IntPair, maxConcurrency: Int) {
-        self.connectedShards.insert(shard.first)
-        let bucketIndex = shard.first / maxConcurrency
-        let start = bucketIndex * maxConcurrency
-        let end = start + maxConcurrency
-        let inBuckets = start..<end
-        if inBuckets.allSatisfy({ self.connectedShards.contains($0) }) {
-            /// All shards in bucket have connected. Tell the waiters of the next bucket index.
-            for waiter in waiters[bucketIndex + 1] ?? [] {
-                waiter.resume()
-            }
-        }
-    }
-}

commit aa2457455b4a12bb50719ec43876d6792cd52b21
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed May 10 03:03:33 2023 +0330

    refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 6115fa1..b4c95a5 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -653,8 +653,8 @@ extension BotGatewayManager {
            let maxConcurrency {
             await Self.shardManager.waitForOtherShards(shard: shard, maxConcurrency: maxConcurrency)
             /// Wait a little bit more. Nothing scientific but seems to make Discord happy `\_()_/`.
-            /// Waits 250 milliseconds more per each total amount of shards.
-            await self.sleep(for: .milliseconds(shard.second * 250))
+            let more = (shard.second / maxConcurrency) * 250
+            await self.sleep(for: .milliseconds(more))
         }
     }
     

commit cd82fc930979f48e0b2905ca426e1130bd9fbd10
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue May 9 19:44:21 2023 +0330

    shard-ing fixes+test & Invalid-token test in BotGatewayManager

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 8c094d3..6115fa1 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -3,6 +3,7 @@ import Foundation
 import AsyncHTTPClient
 import Atomics
 import Logging
+import DiscordModels
 import enum NIOWebSocket.WebSocketErrorCode
 
 public actor BotGatewayManager: GatewayManager {
@@ -55,8 +56,8 @@ public actor BotGatewayManager: GatewayManager {
     var resumeGatewayURL: String? = nil
     
     //MARK: Shard-ing
+    private static let shardManager = ShardManager()
     var maxConcurrency: Int? = nil
-    var isFirstConnection = true
     
     //MARK: Compression
     let compression: Bool
@@ -295,7 +296,6 @@ public actor BotGatewayManager: GatewayManager {
         }
         self.connectionId.wrappingIncrement(ordering: .relaxed)
         self._state.store(.stopped, ordering: .relaxed)
-        self.isFirstConnection = true
         await connectionBackoff.resetTryCount()
         await self.sendQueue.reset()
         self.closeWebSocket(ws: self.ws)
@@ -392,7 +392,7 @@ extension BotGatewayManager {
             self.sendResume(sessionId: sessionId, sequenceNumber: lastSequenceNumber)
         } else {
             logger.debug("Can't resume last Discord connection. Will identify", metadata: [
-                "sessionId_length": .stringConvertible(self.sessionId?.count ?? -1),
+                "sessionId": .stringConvertible(self.sessionId ?? "nil"),
                 "lastSequenceNumber": .stringConvertible(self.sequenceNumber ?? -1)
             ])
             await self.sendIdentify()
@@ -599,6 +599,10 @@ extension BotGatewayManager {
                 
                 if let ws = await self.ws {
                     do {
+                        self.logger.trace("Will send a payload", metadata: [
+                            "payload": .string("\(payload)"),
+                            "opcode": .stringConvertible(opcode)
+                        ])
                         try await ws.send(
                             raw: data,
                             opcode: .init(encodedWebSocketOpcode: opcode)!
@@ -634,22 +638,23 @@ extension BotGatewayManager {
         await connectionBackoff.resetTryCount()
         self.unsuccessfulPingsCount = 0
         await self.sendQueue.reset()
+        if let shard = self.identifyPayload.shard,
+           let maxConcurrency = self.maxConcurrency {
+            await Self.shardManager.connected(shard: shard, maxConcurrency: maxConcurrency)
+        }
     }
-    
+
+    /// Discord says: "you must start the shard buckets in "order". That means that you can start shard 0 -> shard 15 concurrently, and then you can start shard 16 -> shard 31."
+    /// https://discord.com/developers/docs/topics/gateway#sharding
+    ///
+    /// This shard-ing logic can't handle out-of-process shards.
     private func waitInShardQueueIfNeeded() async {
-        if isFirstConnection,
-           let shard = identifyPayload.shard,
+        if let shard = self.identifyPayload.shard,
            let maxConcurrency {
-            isFirstConnection = false
-            let bucketIndex = shard.first / maxConcurrency
-            if bucketIndex > 0 {
-                /// Wait 2 seconds for each bucket index.
-                /// These 2 seconds is nothing scientific.
-                /// Optimally we should implement managing all shards of a bot together
-                /// so we can know when shards connect and can start the new bucket, but that
-                /// comes with complications as shards might be running on more than 1 process.
-                await self.sleep(for: .seconds(Int64(bucketIndex) * 2))
-            }
+            await Self.shardManager.waitForOtherShards(shard: shard, maxConcurrency: maxConcurrency)
+            /// Wait a little bit more. Nothing scientific but seems to make Discord happy `\_()_/`.
+            /// Waits 250 milliseconds more per each total amount of shards.
+            await self.sleep(for: .milliseconds(shard.second * 250))
         }
     }
     
@@ -676,3 +681,44 @@ extension BotGatewayManager {
         }
     }
 }
+
+private actor ShardManager {
+    /// [BucketIndex: Continuations]
+    var waiters = [Int: [CheckedContinuation<Void, Never>]]()
+    var connectedShards = Set<Int>()
+
+    func waitForOtherShards(shard: IntPair, maxConcurrency: Int) async {
+        let bucketIndex = shard.first / maxConcurrency
+        if bucketIndex == 0 {
+            return
+        } else {
+            /// If other shards are already connected, return immediately.
+            let lastBucketIndex = bucketIndex - 1
+            let start = lastBucketIndex * maxConcurrency
+            let end = start + maxConcurrency
+            let inBuckets = start..<end
+            if inBuckets.allSatisfy({ self.connectedShards.contains($0) }) {
+                return
+            } else {
+                /// If other shards are **not** already connected, wait.
+                await withCheckedContinuation {
+                    self.waiters[bucketIndex, default: []].append($0)
+                }
+            }
+        }
+    }
+
+    func connected(shard: IntPair, maxConcurrency: Int) {
+        self.connectedShards.insert(shard.first)
+        let bucketIndex = shard.first / maxConcurrency
+        let start = bucketIndex * maxConcurrency
+        let end = start + maxConcurrency
+        let inBuckets = start..<end
+        if inBuckets.allSatisfy({ self.connectedShards.contains($0) }) {
+            /// All shards in bucket have connected. Tell the waiters of the next bucket index.
+            for waiter in waiters[bucketIndex + 1] ?? [] {
+                waiter.resume()
+            }
+        }
+    }
+}

commit 744fe129fecc2519607b1700bc87a59ebd786362
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue May 9 10:33:19 2023 +0330

    improve code-cov

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 2f9bc57..8c094d3 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -463,7 +463,7 @@ extension BotGatewayManager {
         guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
         Task {
             let (code, codeDesc) = self.getCloseCodeAndDescription(of: ws)
-            let isDebugLevelCode = [.goingAway, nil, .unexpectedServerError].contains(code)
+            let isDebugLevelCode = [nil, .goingAway, .unexpectedServerError].contains(code)
             self.logger.log(
                 level: isDebugLevelCode ? .debug : .warning,
                 "Received connection close notification. Will try to reconnect",

commit d97244a529f828a2781b8cbfcdbe8675c62f220d
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sun May 7 18:30:32 2023 +0330

    Drop macOS 12 / older OS versions + related cleanups (#46)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index a13c9ce..2f9bc57 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -4,7 +4,6 @@ import AsyncHTTPClient
 import Atomics
 import Logging
 import enum NIOWebSocket.WebSocketErrorCode
-import struct NIOCore.TimeAmount
 
 public actor BotGatewayManager: GatewayManager {
     
@@ -190,7 +189,7 @@ public actor BotGatewayManager: GatewayManager {
         /// Guard we're attempting to connect too fast
         if let connectIn = await connectionBackoff.canPerformIn() {
             logger.warning("Cannot try to connect immediately due to backoff", metadata: [
-                "wait-milliseconds": .stringConvertible(connectIn.nanoseconds / 1_000_000)
+                "wait-time": .stringConvertible(connectIn)
             ])
             await self.sleep(for: connectIn)
         }
@@ -521,10 +520,10 @@ extension BotGatewayManager {
     
     private func setupPingTask(
         forConnectionWithId connectionId: UInt,
-        every interval: TimeAmount
+        every duration: Duration
     ) {
         Task {
-            await self.sleep(for: interval)
+            await self.sleep(for: duration)
             guard self.connectionId.load(ordering: .relaxed) == connectionId else {
                 self.logger.trace("Canceled a ping task", metadata: [
                     "connectionId": .stringConvertible(connectionId)
@@ -535,7 +534,7 @@ extension BotGatewayManager {
                 "connectionId": .stringConvertible(connectionId)
             ])
             self.sendPing(forConnectionWithId: connectionId)
-            self.setupPingTask(forConnectionWithId: connectionId, every: interval)
+            self.setupPingTask(forConnectionWithId: connectionId, every: duration)
         }
     }
     
@@ -667,9 +666,9 @@ extension BotGatewayManager {
         }
     }
     
-    private func sleep(for time: TimeAmount) async {
+    private func sleep(for duration: Duration) async {
         do {
-            try await Task.sleep(nanoseconds: UInt64(time.nanoseconds))
+            try await Task.sleep(for: duration)
         } catch {
             logger.warning("Task failed to sleep properly", metadata: [
                 "error": .string("\(error)")

commit 180b6248b7fab49fd2280ea8b36c483a27ee20b8
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 5 19:05:41 2023 +0330

    Don't stop streams even if `BotGatewayManager` is done

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 63c42c6..a13c9ce 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -483,22 +483,11 @@ extension BotGatewayManager {
                 self.connectionId.wrappingIncrement(ordering: .relaxed)
                 self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/MahdiBM/DiscordBM/issues if you think this is a library issue")
 
-                /// End streams
-                for continuation in self.eventStreamContinuations {
-                    continuation.finish()
-                }
-                for continuation in self.eventParseFailureContinuations {
-                    continuation.finish()
-                }
-                self.removeAllEventContinuations()
+                /// Don't remove/end the event streams just to stop apps from crashing/restarting
+                /// which could result in bot-token revocations or even temporary ip bans.
             }
         }
     }
-
-    private func removeAllEventContinuations() {
-        self.eventStreamContinuations.removeAll()
-        self.eventParseFailureContinuations.removeAll()
-    }
     
     private nonisolated func getCloseCodeAndDescription(
         of ws: WebSocket

commit 40d97c156cb346a0979449b2a8e10464563a85ee
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 5 13:12:47 2023 +0330

    `BotGatewayManager.connect()` wait for full web-socket connection

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index c599cf3..63c42c6 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -233,11 +233,11 @@ public actor BotGatewayManager: GatewayManager {
             self.ws = ws
             self._state.store(.configured, ordering: .relaxed)
         } catch {
-            logger.error("web-socket error while connecting to Discord", metadata: [
+            logger.error("web-socket error while connecting to Discord. Will try again", metadata: [
                 "error": .string("\(error)")
             ])
             self._state.store(.noConnection, ordering: .relaxed)
-            Task { await self.connect() }
+            await self.connect()
         }
     }
     

commit 1298ebdf35f791d84fd5bb3988a96bd00fed5704
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 5 09:58:03 2023 +0330

    use `if let *` instead of `if let * = *`

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 27e8383..c599cf3 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -590,7 +590,7 @@ extension BotGatewayManager {
         self.sendQueue.perform { [weak self] in
             guard let self = self else { return }
             Task {
-                if let connectionId = connectionId,
+                if let connectionId,
                    self.connectionId.load(ordering: .relaxed) != connectionId {
                     return
                 }
@@ -651,7 +651,7 @@ extension BotGatewayManager {
     private func waitInShardQueueIfNeeded() async {
         if isFirstConnection,
            let shard = identifyPayload.shard,
-           let maxConcurrency = maxConcurrency {
+           let maxConcurrency {
             isFirstConnection = false
             let bucketIndex = shard.first / maxConcurrency
             if bucketIndex > 0 {

commit 1094b962bc6ace6b1784c09f12ee31e7fc899c3e
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 5 02:31:42 2023 +0330

    simpler web-socket incoming-buffer handling

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 511b07a..27e8383 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -225,8 +225,7 @@ public actor BotGatewayManager: GatewayManager {
                 to: gatewayURL + urlSuffix,
                 configuration: configuration,
                 on: eventLoopGroup,
-                onText: onBuffer,
-                onBinary: onBuffer,
+                onBuffer: onBuffer,
                 onClose: onClose
             )
             self.logger.debug("Connected to Discord through web-socket. Will configure")

commit f188b20eb6c05ebd091a5811f1b34b8ed0315e71
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri May 5 02:23:33 2023 +0330

    minor documentation refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index acd0b8e..511b07a 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -12,7 +12,7 @@ public actor BotGatewayManager: GatewayManager {
     let eventLoopGroup: any EventLoopGroup
     /// A client to send requests to Discord.
     public nonisolated let client: any DiscordClient
-    /// Max frame size we accept to receive through the websocket connection.
+    /// Max frame size we accept to receive through the web-socket connection.
     nonisolated let maxFrameSize: Int
     /// Generator of `BotGatewayManager` ids.
     static let idGenerator = ManagedAtomic(UInt(0))
@@ -21,7 +21,7 @@ public actor BotGatewayManager: GatewayManager {
         .wrappingIncrementThenLoad(ordering: .relaxed)
     let logger: Logger
     
-    //MARK: Event handlers
+    //MARK: Event streams
     var eventStreamContinuations = [AsyncStream<Gateway.Event>.Continuation]()
     var eventParseFailureContinuations = [AsyncStream<(Error, ByteBuffer)>.Continuation]()
     
@@ -323,7 +323,7 @@ extension BotGatewayManager {
         
         switch event.data {
         case let .invalidSession(canResume):
-            logger.warning("Got invalid session. Will try to reconnect", metadata: [
+            logger.warning("Got invalid session. Will try to reconnect or resume", metadata: [
                 "canResume": .stringConvertible(canResume)
             ])
             if !canResume {
@@ -501,7 +501,7 @@ extension BotGatewayManager {
         self.eventParseFailureContinuations.removeAll()
     }
     
-    private nonisolated  func getCloseCodeAndDescription(
+    private nonisolated func getCloseCodeAndDescription(
         of ws: WebSocket
     ) -> (WebSocketErrorCode?, String) {
         let code = ws.closeCode
@@ -659,9 +659,8 @@ extension BotGatewayManager {
                 /// Wait 2 seconds for each bucket index.
                 /// These 2 seconds is nothing scientific.
                 /// Optimally we should implement managing all shards of a bot together
-                /// so we can know when shards connect and can start the new bucket, but
-                /// that doesn't seem easy as shards might be running outside only 1
-                /// process and we won't be able to manage them easily.
+                /// so we can know when shards connect and can start the new bucket, but that
+                /// comes with complications as shards might be running on more than 1 process.
                 await self.sleep(for: .seconds(Int64(bucketIndex) * 2))
             }
         }

commit 3b2adf9d26ea2f72d342c30328632f155ec9c969
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Thu May 4 08:04:00 2023 +0330

    more web-socket refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 2b53bbc..acd0b8e 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -218,20 +218,23 @@ public actor BotGatewayManager: GatewayManager {
             let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
                 Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
             }
+            let onClose: @Sendable (WebSocket) -> Void = { ws in
+                Task { await self.setupOnClose(ws: ws, forConnectionWithId: connectionId) }
+            }
             let ws = try await WebSocket.connect(
                 to: gatewayURL + urlSuffix,
                 configuration: configuration,
                 on: eventLoopGroup,
                 onText: onBuffer,
-                onBinary: onBuffer
+                onBinary: onBuffer,
+                onClose: onClose
             )
             self.logger.debug("Connected to Discord through web-socket. Will configure")
             self.closeWebSocket(ws: self.ws)
             self.ws = ws
-            self.setupOnClose(forConnectionWithId: connectionId)
             self._state.store(.configured, ordering: .relaxed)
         } catch {
-            logger.error("WebSocket error while connecting to Discord", metadata: [
+            logger.error("web-socket error while connecting to Discord", metadata: [
                 "error": .string("\(error)")
             ])
             self._state.store(.noConnection, ordering: .relaxed)
@@ -302,12 +305,6 @@ public actor BotGatewayManager: GatewayManager {
 }
 
 extension BotGatewayManager {
-    private func configureWebSocket() {
-        let connId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
-        self.setupOnClose(forConnectionWithId: connId)
-        self._state.store(.configured, ordering: .relaxed)
-    }
-    
     private func processEvent(_ event: Gateway.Event) async {
         if let sequenceNumber = event.sequenceNumber {
             self.sequenceNumber = sequenceNumber
@@ -463,45 +460,38 @@ extension BotGatewayManager {
         }
     }
     
-    private func setupOnClose(forConnectionWithId connectionId: UInt) {
-        guard let ws = self.ws else {
-            logger.error("Cannot setup web-socket on-close because there are no active web-sockets. This is an issue in the library, please report: https://github.com/MahdiBM/DiscordBM/issues")
-            return
-        }
-        ws.onClose.whenComplete { [weak self] _ in
-            guard let `self` = self else { return }
-            self.logger.debug("Received connection close notification for a web-socket")
-            guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
-            Task {
-                let (code, codeDesc) = self.getCloseCodeAndDescription(of: ws)
-                let isDebugLevelCode = [.goingAway, nil, .unexpectedServerError].contains(code)
-                self.logger.log(
-                    level: isDebugLevelCode ? .debug : .warning,
-                    "Received connection close notification. Will try to reconnect",
-                    metadata: [
-                        "code": .string(codeDesc),
-                        "closedConnectionId": .stringConvertible(
-                            self.connectionId.load(ordering: .relaxed)
-                        )
-                    ]
-                )
-                if self.canTryReconnect(code: ws.closeCode) {
-                    self._state.store(.noConnection, ordering: .relaxed)
-                    await self.connect()
-                } else {
-                    self._state.store(.stopped, ordering: .relaxed)
-                    self.connectionId.wrappingIncrement(ordering: .relaxed)
-                    self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/MahdiBM/DiscordBM/issues if you think this is a library issue")
+    private func setupOnClose(ws: WebSocket, forConnectionWithId connectionId: UInt) {
+        self.logger.debug("Received connection close notification for a web-socket")
+        guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
+        Task {
+            let (code, codeDesc) = self.getCloseCodeAndDescription(of: ws)
+            let isDebugLevelCode = [.goingAway, nil, .unexpectedServerError].contains(code)
+            self.logger.log(
+                level: isDebugLevelCode ? .debug : .warning,
+                "Received connection close notification. Will try to reconnect",
+                metadata: [
+                    "code": .string(codeDesc),
+                    "closedConnectionId": .stringConvertible(
+                        self.connectionId.load(ordering: .relaxed)
+                    )
+                ]
+            )
+            if self.canTryReconnect(code: ws.closeCode) {
+                self._state.store(.noConnection, ordering: .relaxed)
+                await self.connect()
+            } else {
+                self._state.store(.stopped, ordering: .relaxed)
+                self.connectionId.wrappingIncrement(ordering: .relaxed)
+                self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/MahdiBM/DiscordBM/issues if you think this is a library issue")
 
-                    /// End streams
-                    for continuation in await self.eventStreamContinuations {
-                        continuation.finish()
-                    }
-                    for continuation in await self.eventParseFailureContinuations {
-                        continuation.finish()
-                    }
-                    await self.removeAllEventContinuations()
+                /// End streams
+                for continuation in self.eventStreamContinuations {
+                    continuation.finish()
+                }
+                for continuation in self.eventParseFailureContinuations {
+                    continuation.finish()
                 }
+                self.removeAllEventContinuations()
             }
         }
     }

commit 3de7dd6e19e0ca132c9eb525312a39e9007a8174
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Thu May 4 06:22:21 2023 +0330

    fix for async/await websocket slowness

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 3ac29b7..2b53bbc 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -214,15 +214,22 @@ public actor BotGatewayManager: GatewayManager {
         }
         logger.trace("Will try to connect to Discord through web-socket")
         do {
+            let connectionId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
+            let onBuffer: @Sendable (ByteBuffer) -> Void = { buffer in
+                Task { await self.processBinaryData(buffer, forConnectionWithId: connectionId) }
+            }
             let ws = try await WebSocket.connect(
                 to: gatewayURL + urlSuffix,
                 configuration: configuration,
-                on: eventLoopGroup
+                on: eventLoopGroup,
+                onText: onBuffer,
+                onBinary: onBuffer
             )
             self.logger.debug("Connected to Discord through web-socket. Will configure")
             self.closeWebSocket(ws: self.ws)
             self.ws = ws
-            self.configureWebSocket()
+            self.setupOnClose(forConnectionWithId: connectionId)
+            self._state.store(.configured, ordering: .relaxed)
         } catch {
             logger.error("WebSocket error while connecting to Discord", metadata: [
                 "error": .string("\(error)")
@@ -297,7 +304,6 @@ public actor BotGatewayManager: GatewayManager {
 extension BotGatewayManager {
     private func configureWebSocket() {
         let connId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
-        self.setupOnText(forConnectionWithId: connId)
         self.setupOnClose(forConnectionWithId: connId)
         self._state.store(.configured, ordering: .relaxed)
     }
@@ -429,18 +435,6 @@ extension BotGatewayManager {
         self.send(payload: identify)
     }
     
-    private func setupOnText(forConnectionWithId connectionId: UInt) {
-        if compression {
-            self.ws?.onBinary { buffer in
-                self.processBinaryData(buffer, forConnectionWithId: connectionId)
-            }
-        } else {
-            self.ws?.onTextBuffer { buffer in
-                self.processBinaryData(buffer, forConnectionWithId: connectionId)
-            }
-        }
-    }
-    
     private func processBinaryData(_ buffer: ByteBuffer, forConnectionWithId connectionId: UInt) {
         self.logger.debug("Got text from websocket", metadata: [
             "text": .string(String(buffer: buffer))

commit e66ae52458570972819c3a8e99333fb6cb3c9a93
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed May 3 15:47:35 2023 +0330

    add websocket tests

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 114af48..3ac29b7 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -431,11 +431,11 @@ extension BotGatewayManager {
     
     private func setupOnText(forConnectionWithId connectionId: UInt) {
         if compression {
-            self.ws?.onBinary { _, buffer in
+            self.ws?.onBinary { buffer in
                 self.processBinaryData(buffer, forConnectionWithId: connectionId)
             }
         } else {
-            self.ws?.onTextBuffer { _, buffer in
+            self.ws?.onTextBuffer { buffer in
                 self.processBinaryData(buffer, forConnectionWithId: connectionId)
             }
         }

commit 8b12d71168ea00ac3bb3195b37656585452953fa
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed May 3 12:02:01 2023 +0330

    more websocket refinements

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index c72bab7..114af48 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -332,8 +332,6 @@ extension BotGatewayManager {
             await self.connect()
         case let .hello(hello):
             logger.debug("Received 'hello'")
-            /// Disable websocket-kit automatic pings
-            self.ws?.pingInterval = nil
             self.setupPingTask(
                 forConnectionWithId: self.connectionId.load(ordering: .relaxed),
                 every: .milliseconds(Int64(hello.heartbeat_interval))
@@ -687,10 +685,14 @@ extension BotGatewayManager {
     
     private nonisolated func closeWebSocket(ws: WebSocket?) {
         logger.debug("Will possibly close a web-socket")
-        ws?.close().whenFailure {
-            self.logger.warning("Connection close error", metadata: [
-                "error": "\($0)"
-            ])
+        Task {
+            do {
+                try await ws?.close()
+            } catch {
+                self.logger.warning("Connection close error", metadata: [
+                    "error": .string("\(error)")
+                ])
+            }
         }
     }
     

commit 834140a6279e710d9bcc21d0411690d3460cf799
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed May 3 11:46:35 2023 +0330

    rename `WebSocketKitFork` to `DiscordWebSocket` + simplifications

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 21e9cd4..c72bab7 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -1,4 +1,4 @@
-import WebSocketKitFork
+import DiscordWebSocket
 import Foundation
 import AsyncHTTPClient
 import Atomics
@@ -213,16 +213,17 @@ public actor BotGatewayManager: GatewayManager {
             configuration.decompression = .enabled
         }
         logger.trace("Will try to connect to Discord through web-socket")
-        WebSocket.connect(
-            to: gatewayURL + urlSuffix,
-            configuration: configuration,
-            on: eventLoopGroup
-        ) { ws in
+        do {
+            let ws = try await WebSocket.connect(
+                to: gatewayURL + urlSuffix,
+                configuration: configuration,
+                on: eventLoopGroup
+            )
             self.logger.debug("Connected to Discord through web-socket. Will configure")
             self.closeWebSocket(ws: self.ws)
             self.ws = ws
             self.configureWebSocket()
-        }.whenFailure { [self] error in
+        } catch {
             logger.error("WebSocket error while connecting to Discord", metadata: [
                 "error": .string("\(error)")
             ])

commit ce82286de94959ee5cdc316fd4f1c34f91f6421c
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed May 3 00:05:27 2023 +0330

    Tagged `Snowflake`s (#43)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 7bf5860..21e9cd4 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -120,7 +120,7 @@ public actor BotGatewayManager: GatewayManager {
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int =  1 << 31,
         compression: Bool = true,
-        appId: String? = nil,
+        appId: ApplicationSnowflake? = nil,
         identifyPayload: Gateway.Identify
     ) {
         self.eventLoopGroup = eventLoopGroup
@@ -157,7 +157,7 @@ public actor BotGatewayManager: GatewayManager {
         maxFrameSize: Int =  1 << 31,
         compression: Bool = true,
         token: String,
-        appId: String? = nil,
+        appId: ApplicationSnowflake? = nil,
         shard: IntPair? = nil,
         presence: Gateway.Identify.Presence? = nil,
         intents: [Gateway.Intent] = []

commit 7e22f61d06385078644cfdf619e11578db6e85bb
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon May 1 08:18:41 2023 +0330

    Fully move to 'make-stream' functions in `GatewayManager` (#42)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index ec93613..7bf5860 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -21,9 +21,9 @@ public actor BotGatewayManager: GatewayManager {
         .wrappingIncrementThenLoad(ordering: .relaxed)
     let logger: Logger
     
-    //MARK: Event hooks
-    var onEvents: [(Gateway.Event) -> ()] = []
-    var onEventParseFailures: [(Error, ByteBuffer) -> ()] = []
+    //MARK: Event handlers
+    var eventStreamContinuations = [AsyncStream<Gateway.Event>.Continuation]()
+    var eventParseFailureContinuations = [AsyncStream<(Error, ByteBuffer)>.Continuation]()
     
     //MARK: Connection data
     nonisolated let identifyPayload: Gateway.Identify
@@ -259,36 +259,21 @@ public actor BotGatewayManager: GatewayManager {
     }
 
     /// Makes an stream of Gateway events.
-    public func makeEventStream() -> AsyncStream<Gateway.Event> {
+    public func makeEventsStream() -> AsyncStream<Gateway.Event> {
         AsyncStream<Gateway.Event> { continuation in
-            self.onEvents.append { event in
-                continuation.yield(event)
-            }
+            self.eventStreamContinuations.append(continuation)
         }
     }
 
     /// Makes an stream of Gateway event parse failures.
-    public func makeEventParseFailureStream() -> AsyncStream<(Error, ByteBuffer)> {
+    public func makeEventsParseFailureStream() -> AsyncStream<(Error, ByteBuffer)> {
         AsyncStream<(Error, ByteBuffer)> { continuation in
-            self.onEventParseFailures.append { error, buffer in
-                continuation.yield((error, buffer))
-            }
+            self.eventParseFailureContinuations.append(continuation)
         }
     }
-
-    /// Adds a handler to be notified of events.
-    public func addEventHandler(_ handler: @Sendable @escaping (Gateway.Event) -> Void) {
-        self.onEvents.append(handler)
-    }
-    
-    /// Adds a handler to be notified of event parsing failures.
-    public func addEventParseFailureHandler(
-        _ handler: @Sendable @escaping (Error, ByteBuffer) -> Void
-    ) {
-        self.onEventParseFailures.append(handler)
-    }
     
     /// Disconnects from Discord.
+    /// Doesn't end the event streams.
     public func disconnect() async {
         logger.debug("Will disconnect", metadata: [
             "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
@@ -472,15 +457,15 @@ extension BotGatewayManager {
                 "event": .string("\(event)")
             ])
             Task { await self.processEvent(event) }
-            for onEvent in self.onEvents {
-                onEvent(event)
+            for continuation in self.eventStreamContinuations {
+                continuation.yield(event)
             }
         } catch {
             self.logger.debug("Failed to decode event", metadata: [
                 "error": .string("\(error)")
             ])
-            for onEventParseFailure in self.onEventParseFailures {
-                onEventParseFailure(error, buffer)
+            for continuation in self.eventParseFailureContinuations {
+                continuation.yield((error, buffer))
             }
         }
     }
@@ -514,10 +499,24 @@ extension BotGatewayManager {
                     self._state.store(.stopped, ordering: .relaxed)
                     self.connectionId.wrappingIncrement(ordering: .relaxed)
                     self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/MahdiBM/DiscordBM/issues if you think this is a library issue")
+
+                    /// End streams
+                    for continuation in await self.eventStreamContinuations {
+                        continuation.finish()
+                    }
+                    for continuation in await self.eventParseFailureContinuations {
+                        continuation.finish()
+                    }
+                    await self.removeAllEventContinuations()
                 }
             }
         }
     }
+
+    private func removeAllEventContinuations() {
+        self.eventStreamContinuations.removeAll()
+        self.eventParseFailureContinuations.removeAll()
+    }
     
     private nonisolated  func getCloseCodeAndDescription(
         of ws: WebSocket

commit 8b2c71110786c148a884b594e7b32691fd5dfc3d
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri Apr 28 15:05:11 2023 +0330

    add make parse-failure stream func to `GatewayManager`

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 85ae5d9..ec93613 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -267,6 +267,15 @@ public actor BotGatewayManager: GatewayManager {
         }
     }
 
+    /// Makes an stream of Gateway event parse failures.
+    public func makeEventParseFailureStream() -> AsyncStream<(Error, ByteBuffer)> {
+        AsyncStream<(Error, ByteBuffer)> { continuation in
+            self.onEventParseFailures.append { error, buffer in
+                continuation.yield((error, buffer))
+            }
+        }
+    }
+
     /// Adds a handler to be notified of events.
     public func addEventHandler(_ handler: @Sendable @escaping (Gateway.Event) -> Void) {
         self.onEvents.append(handler)

commit 611b667fce617e7e96607626cccf77848095d0bc
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri Apr 28 12:23:49 2023 +0330

    add function returning async-stream for Gateway events

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index e4cec87..85ae5d9 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -257,7 +257,16 @@ public actor BotGatewayManager: GatewayManager {
             data: .requestVoiceStateUpdate(payload)
         ), opcode: 10)
     }
-    
+
+    /// Makes an stream of Gateway events.
+    public func makeEventStream() -> AsyncStream<Gateway.Event> {
+        AsyncStream<Gateway.Event> { continuation in
+            self.onEvents.append { event in
+                continuation.yield(event)
+            }
+        }
+    }
+
     /// Adds a handler to be notified of events.
     public func addEventHandler(_ handler: @Sendable @escaping (Gateway.Event) -> Void) {
         self.onEvents.append(handler)

commit c15831ce18e925a977ccf80edc15c8509fa2cd6b
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue Apr 25 21:49:18 2023 +0330

    `BotGatewayManager` logging refinements + minor cleanup

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index d19f1ba..e4cec87 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -224,7 +224,7 @@ public actor BotGatewayManager: GatewayManager {
             self.configureWebSocket()
         }.whenFailure { [self] error in
             logger.error("WebSocket error while connecting to Discord", metadata: [
-                "error": "\(error)"
+                "error": .string("\(error)")
             ])
             self._state.store(.noConnection, ordering: .relaxed)
             Task { await self.connect() }
@@ -356,7 +356,7 @@ extension BotGatewayManager {
         logger.debug("Will try to get Discord gateway url")
         if self.sequenceNumber != nil, /// If can resume at all
            let gatewayURL = self.resumeGatewayURL {
-            logger.trace("Got Discord gateway url from `resumeGatewayURL`")
+            logger.trace("Got Discord gateway url from 'resumeGatewayURL'")
             return gatewayURL
         } else {
             /// If the bot is using shard-ing, we need to call a different endpoint
@@ -368,7 +368,11 @@ extension BotGatewayManager {
                 }
             } else {
                 if let gatewayBot = try? await client.getBotGateway().decode() {
-                    logger.trace("Got Discord gateway url from gateway-bot api call. Max concurrency: \(gatewayBot.session_start_limit.max_concurrency)")
+                    logger.trace("Got Discord gateway url from gateway-bot api call", metadata: [
+                        "max_concurrency": .stringConvertible(
+                            gatewayBot.session_start_limit.max_concurrency
+                        )
+                    ])
                     self.maxConcurrency = gatewayBot.session_start_limit.max_concurrency
                     return gatewayBot.url
                 }
@@ -436,7 +440,9 @@ extension BotGatewayManager {
     }
     
     private func processBinaryData(_ buffer: ByteBuffer, forConnectionWithId connectionId: UInt) {
-        self.logger.debug("Got text from websocket \(String(buffer: buffer))")
+        self.logger.debug("Got text from websocket", metadata: [
+            "text": .string(String(buffer: buffer))
+        ])
         guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
         let data = Data(buffer: buffer)
         do {
@@ -444,13 +450,17 @@ extension BotGatewayManager {
                 Gateway.Event.self,
                 from: data
             )
-            self.logger.debug("Decoded event: \(event)")
+            self.logger.debug("Decoded event", metadata: [
+                "event": .string("\(event)")
+            ])
             Task { await self.processEvent(event) }
             for onEvent in self.onEvents {
                 onEvent(event)
             }
         } catch {
-            self.logger.debug("Failed to decode event. Error: \(error)")
+            self.logger.debug("Failed to decode event", metadata: [
+                "error": .string("\(error)")
+            ])
             for onEventParseFailure in self.onEventParseFailures {
                 onEventParseFailure(error, buffer)
             }
@@ -528,17 +538,23 @@ extension BotGatewayManager {
         Task {
             await self.sleep(for: interval)
             guard self.connectionId.load(ordering: .relaxed) == connectionId else {
-                self.logger.trace("Canceled a ping task with connection id: \(connectionId)")
+                self.logger.trace("Canceled a ping task", metadata: [
+                    "connectionId": .stringConvertible(connectionId)
+                ])
                 return /// cancel
             }
-            self.logger.debug("Will send automatic ping for connection id: \(connectionId)")
+            self.logger.debug("Will send automatic ping", metadata: [
+                "connectionId": .stringConvertible(connectionId)
+            ])
             self.sendPing(forConnectionWithId: connectionId)
             self.setupPingTask(forConnectionWithId: connectionId, every: interval)
         }
     }
     
     private func sendPing(forConnectionWithId connectionId: UInt) {
-        logger.trace("Will ping for connection id \(connectionId)")
+        logger.trace("Will ping", metadata: [
+            "connectionId": .stringConvertible(connectionId)
+        ])
         self.send(payload: .init(
             opcode: .heartbeat,
             data: .heartbeat(lastSequenceNumber: self.sequenceNumber)
@@ -602,7 +618,7 @@ extension BotGatewayManager {
                         )
                     } catch {
                         self.logger.error("Could not send payload through websocket", metadata: [
-                            "error": "\(error)",
+                            "error": .string("\(error)"),
                             "payload": .string("\(payload)"),
                             "opcode": .stringConvertible(opcode),
                             "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
@@ -665,7 +681,7 @@ extension BotGatewayManager {
             try await Task.sleep(nanoseconds: UInt64(time.nanoseconds))
         } catch {
             logger.warning("Task failed to sleep properly", metadata: [
-                "error": "\(error)"
+                "error": .string("\(error)")
             ])
         }
     }

commit f501fd636d89a6c4eac0a5a40d771016cfde6b99
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed Apr 19 00:58:32 2023 +0330

    `GatwayManager.id: Int` -> `UInt`

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index b4f5c87..d19f1ba 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -15,7 +15,7 @@ public actor BotGatewayManager: GatewayManager {
     /// Max frame size we accept to receive through the websocket connection.
     nonisolated let maxFrameSize: Int
     /// Generator of `BotGatewayManager` ids.
-    static let idGenerator = ManagedAtomic(0)
+    static let idGenerator = ManagedAtomic(UInt(0))
     /// This gateway manager's identifier.
     public nonisolated let id = BotGatewayManager.idGenerator
         .wrappingIncrementThenLoad(ordering: .relaxed)

commit a8d996ccd9be5a325600ae6b9e9a62f2cb3ff6f7
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed Apr 5 17:50:05 2023 +0330

    update with new Discord API changes

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index b26e16a..b4f5c87 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -586,7 +586,7 @@ extension BotGatewayManager {
                 do {
                     data = try DiscordGlobalConfiguration.encoder.encode(payload)
                 } catch {
-                    self.logger.error("Could not encode payload. This is a library issue, please report on https://github.com/MahdiBM/DiscordBM/issues", metadata: [
+                    self.logger.error("Could not encode payload", metadata: [
                         "payload": .string("\(payload)"),
                         "opcode": .stringConvertible(opcode),
                         "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
@@ -601,7 +601,7 @@ extension BotGatewayManager {
                             opcode: .init(encodedWebSocketOpcode: opcode)!
                         )
                     } catch {
-                        self.logger.error("Could not send payload through websocket. This is warning if something goes wrong, not necessarily an error", metadata: [
+                        self.logger.error("Could not send payload through websocket", metadata: [
                             "error": "\(error)",
                             "payload": .string("\(payload)"),
                             "opcode": .stringConvertible(opcode),

commit 5bbf487d382ddc286088a32f13d95ccf47af6377
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue Apr 4 14:05:49 2023 +0330

    require updated package versions, remove @preconcurrency Atomics imports

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 4dd20e0..b26e16a 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -1,11 +1,7 @@
-#if swift(>=5.8)
-@preconcurrency import Atomics
-#else
-import Atomics
-#endif
 import WebSocketKitFork
 import Foundation
 import AsyncHTTPClient
+import Atomics
 import Logging
 import enum NIOWebSocket.WebSocketErrorCode
 import struct NIOCore.TimeAmount

commit 735b7655681379637b866b5ad101d08c7f6cf331
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue Apr 4 13:44:05 2023 +0330

    better BotGatewayManager logs

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index fc1b369..4dd20e0 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -613,11 +613,18 @@ extension BotGatewayManager {
                         ])
                     }
                 } else {
-                    self.logger.warning("Trying to send through ws when a connection is not established", metadata: [
-                        "payload": .string("\(payload)"),
-                        "state": .stringConvertible(self._state.load(ordering: .relaxed)),
-                        "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
-                    ])
+                    /// Pings aka `heartbeat`s are fine if they are sent when a ws connection
+                    /// is not established. Pings are not disabled after a connection goes down
+                    /// so long story short, the gateway manager never gets stuck in a bad
+                    /// cycle of no-connection.
+                    self.logger.log(
+                        level: (payload.opcode == .heartbeat) ? .debug : .warning,
+                        "Trying to send through ws when a connection is not established",
+                        metadata: [
+                            "payload": .string("\(payload)"),
+                            "state": .stringConvertible(self._state.load(ordering: .relaxed)),
+                            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                        ])
                 }
             }
         }

commit a6cb63cc1583c9cb57c7e9576d635f7927307602
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sat Mar 25 17:09:54 2023 +0330

    Autogenerate all endpoints (not all added to DiscordClient yet) (#37)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 1b6c403..fc1b369 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -371,7 +371,7 @@ extension BotGatewayManager {
                     return gatewayURL
                 }
             } else {
-                if let gatewayBot = try? await client.getGatewayBot().decode() {
+                if let gatewayBot = try? await client.getBotGateway().decode() {
                     logger.trace("Got Discord gateway url from gateway-bot api call. Max concurrency: \(gatewayBot.session_start_limit.max_concurrency)")
                     self.maxConcurrency = gatewayBot.session_start_limit.max_concurrency
                     return gatewayBot.url

commit 39c4be94d03b2aca7601babd4d70b3332d058b9c
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed Feb 22 15:43:27 2023 +0330

    Lots of refinements (#36)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 6cc19fb..1b6c403 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -502,7 +502,7 @@ extension BotGatewayManager {
         let description: String
         switch code {
         case let .unknown(codeNumber):
-            switch Gateway.CloseCode(rawValue: codeNumber) {
+            switch GatewayCloseCode(rawValue: codeNumber) {
             case let .some(discordCode):
                 description = "\(discordCode)"
             case .none:
@@ -519,7 +519,7 @@ extension BotGatewayManager {
     private nonisolated func canTryReconnect(code: WebSocketErrorCode?) -> Bool {
         switch code {
         case let .unknown(codeNumber):
-            guard let discordCode = Gateway.CloseCode(rawValue: codeNumber) else { return true }
+            guard let discordCode = GatewayCloseCode(rawValue: codeNumber) else { return true }
             return discordCode.canTryReconnect
         default: return true
         }

commit ac3e41538553b4b9c8bd0232e30850a199a0648f
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Fri Feb 17 23:43:22 2023 +0330

    Fix Swift 5.8 nightly warnings (Xcode 14.3 b1) (#35)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 52d00f1..6cc19fb 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -1,7 +1,11 @@
-import Foundation
+#if swift(>=5.8)
+@preconcurrency import Atomics
+#else
+import Atomics
+#endif
 import WebSocketKitFork
+import Foundation
 import AsyncHTTPClient
-import Atomics
 import Logging
 import enum NIOWebSocket.WebSocketErrorCode
 import struct NIOCore.TimeAmount
@@ -259,12 +263,14 @@ public actor BotGatewayManager: GatewayManager {
     }
     
     /// Adds a handler to be notified of events.
-    public func addEventHandler(_ handler: @escaping (Gateway.Event) -> Void) {
+    public func addEventHandler(_ handler: @Sendable @escaping (Gateway.Event) -> Void) {
         self.onEvents.append(handler)
     }
     
     /// Adds a handler to be notified of event parsing failures.
-    public func addEventParseFailureHandler(_ handler: @escaping (Error, ByteBuffer) -> Void) {
+    public func addEventParseFailureHandler(
+        _ handler: @Sendable @escaping (Error, ByteBuffer) -> Void
+    ) {
         self.onEventParseFailures.append(handler)
     }
     

commit 4dda55238a85efb98de71df86c4103b33ef9626b
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sun Feb 12 20:04:12 2023 +0330

    React-to-Role (#28)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 53f2f43..52d00f1 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -90,11 +90,9 @@ public actor BotGatewayManager: GatewayManager {
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
         eventLoopGroup: EventLoopGroup,
-        httpClient: HTTPClient,
         client: any DiscordClient,
         maxFrameSize: Int =  1 << 31,
         compression: Bool = true,
-        appId: String? = nil,
         identifyPayload: Gateway.Identify
     ) {
         self.eventLoopGroup = eventLoopGroup
@@ -275,12 +273,18 @@ public actor BotGatewayManager: GatewayManager {
         logger.debug("Will disconnect", metadata: [
             "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
         ])
+        if self._state.load(ordering: .relaxed) == .stopped {
+            logger.debug("Already disconnected", metadata: [
+                "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+            ])
+            return
+        }
         self.connectionId.wrappingIncrement(ordering: .relaxed)
-        await connectionBackoff.resetTryCount()
-        self.closeWebSocket(ws: self.ws)
         self._state.store(.stopped, ordering: .relaxed)
         self.isFirstConnection = true
+        await connectionBackoff.resetTryCount()
         await self.sendQueue.reset()
+        self.closeWebSocket(ws: self.ws)
     }
 }
 
@@ -566,7 +570,8 @@ extension BotGatewayManager {
         connectionId: UInt? = nil,
         tryCount: Int = 0
     ) {
-        self.sendQueue.perform { [self] in
+        self.sendQueue.perform { [weak self] in
+            guard let self = self else { return }
             Task {
                 if let connectionId = connectionId,
                    self.connectionId.load(ordering: .relaxed) != connectionId {
@@ -579,7 +584,7 @@ extension BotGatewayManager {
                 do {
                     data = try DiscordGlobalConfiguration.encoder.encode(payload)
                 } catch {
-                    logger.error("Could not encode payload. This is a library issue, please report on https://github.com/MahdiBM/DiscordBM/issues", metadata: [
+                    self.logger.error("Could not encode payload. This is a library issue, please report on https://github.com/MahdiBM/DiscordBM/issues", metadata: [
                         "payload": .string("\(payload)"),
                         "opcode": .stringConvertible(opcode),
                         "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
@@ -594,7 +599,7 @@ extension BotGatewayManager {
                             opcode: .init(encodedWebSocketOpcode: opcode)!
                         )
                     } catch {
-                        logger.error("Could not send payload through websocket", metadata: [
+                        self.logger.error("Could not send payload through websocket. This is warning if something goes wrong, not necessarily an error", metadata: [
                             "error": "\(error)",
                             "payload": .string("\(payload)"),
                             "opcode": .stringConvertible(opcode),
@@ -602,7 +607,7 @@ extension BotGatewayManager {
                         ])
                     }
                 } else {
-                    logger.warning("Trying to send through ws when a connection is not established", metadata: [
+                    self.logger.warning("Trying to send through ws when a connection is not established", metadata: [
                         "payload": .string("\(payload)"),
                         "state": .stringConvertible(self._state.load(ordering: .relaxed)),
                         "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))

commit 723e00a1c2b490d82fb371079f348713c8ba8cf6
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Mon Feb 6 17:21:39 2023 +0330

    fix the two new Gateway functions + their test

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 06018f8..53f2f43 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -244,20 +244,20 @@ public actor BotGatewayManager: GatewayManager {
     
     /// https://discord.com/developers/docs/topics/gateway-events#update-presence
     public func updatePresence(payload: Gateway.Identify.Presence) {
-        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
+        /// This took a lot of time to figure out, not sure why it needs opcode `9` (works with `10` too?!).
         self.send(payload: .init(
             opcode: .presenceUpdate,
             data: .requestPresenceUpdate(payload)
-        ), opcode: 1)
+        ), opcode: 9)
     }
     
     /// https://discord.com/developers/docs/topics/gateway-events#update-voice-state
     public func updateVoiceState(payload: VoiceStateUpdate) {
-        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
+        /// This took a lot of time to figure out, not sure why it needs opcode `10` (works with `9` too?!).
         self.send(payload: .init(
             opcode: .voiceStateUpdate,
             data: .requestVoiceStateUpdate(payload)
-        ), opcode: 1)
+        ), opcode: 10)
     }
     
     /// Adds a handler to be notified of events.

commit ca127d1f1b2d1f278191a8c0480ffda1046b1286
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Sun Feb 5 23:52:24 2023 +0330

    add 2 missing gateway requests

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index c564bc5..06018f8 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -233,8 +233,7 @@ public actor BotGatewayManager: GatewayManager {
         }
     }
     
-    /// Requests guild members from Discord.
-    /// Refer to the documentation link of ``Gateway.RequestGuildMembers`` for more info.
+    /// https://discord.com/developers/docs/topics/gateway-events#request-guild-members
     public func requestGuildMembersChunk(payload: Gateway.RequestGuildMembers) {
         /// This took a lot of time to figure out, not sure why it needs opcode `1`.
         self.send(payload: .init(
@@ -243,6 +242,24 @@ public actor BotGatewayManager: GatewayManager {
         ), opcode: 1)
     }
     
+    /// https://discord.com/developers/docs/topics/gateway-events#update-presence
+    public func updatePresence(payload: Gateway.Identify.Presence) {
+        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
+        self.send(payload: .init(
+            opcode: .presenceUpdate,
+            data: .requestPresenceUpdate(payload)
+        ), opcode: 1)
+    }
+    
+    /// https://discord.com/developers/docs/topics/gateway-events#update-voice-state
+    public func updateVoiceState(payload: VoiceStateUpdate) {
+        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
+        self.send(payload: .init(
+            opcode: .voiceStateUpdate,
+            data: .requestVoiceStateUpdate(payload)
+        ), opcode: 1)
+    }
+    
     /// Adds a handler to be notified of events.
     public func addEventHandler(_ handler: @escaping (Gateway.Event) -> Void) {
         self.onEvents.append(handler)

commit 7d6853566ed6cea53e535b8c95b34bb6c333c9a2
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue Jan 31 19:31:19 2023 +0330

    enable Gateway compression by default

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 8985c72..c564bc5 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -67,7 +67,7 @@ public actor BotGatewayManager: GatewayManager {
     /// Discord cares about the identify payload for rate-limiting and if we send
     /// more than 1000 identifies in a day, Discord will revoke the bot token.
     /// This Backoff does not necessarily prevent your bot token getting revoked,
-    /// but in the worst case, doesn't let it happen sooner than ~8 hours.
+    /// but in the worst case, doesn't let it happen sooner than ~6 hours.
     /// This also helps in other situations, for example when there is a Discord outage.
     let connectionBackoff = Backoff(
         base: 2,
@@ -85,8 +85,7 @@ public actor BotGatewayManager: GatewayManager {
     ///   - httpClient: A `HTTPClient`.
     ///   - client: A `DiscordClient` to use.
     ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
-    ///   - compression: Enables transport compression for less network bandwidth usage
-    ///    but more CPU load.
+    ///   - compression: Enables transport compression for less network bandwidth usage.
     ///   - appId: Your Discord application id.
     ///   - identifyPayload: The identification payload that is sent to Discord.
     public init(
@@ -94,7 +93,7 @@ public actor BotGatewayManager: GatewayManager {
         httpClient: HTTPClient,
         client: any DiscordClient,
         maxFrameSize: Int =  1 << 31,
-        compression: Bool = false,
+        compression: Bool = true,
         appId: String? = nil,
         identifyPayload: Gateway.Identify
     ) {
@@ -122,7 +121,7 @@ public actor BotGatewayManager: GatewayManager {
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int =  1 << 31,
-        compression: Bool = false,
+        compression: Bool = true,
         appId: String? = nil,
         identifyPayload: Gateway.Identify
     ) {
@@ -158,7 +157,7 @@ public actor BotGatewayManager: GatewayManager {
         httpClient: HTTPClient,
         clientConfiguration: ClientConfiguration = .init(),
         maxFrameSize: Int =  1 << 31,
-        compression: Bool = false,
+        compression: Bool = true,
         token: String,
         appId: String? = nil,
         shard: IntPair? = nil,

commit a8e97475ebcb9f2ee3e552d5ea6a4762838f0517
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Thu Jan 26 17:40:23 2023 +0330

    better Gateway logs + better logger mentions + updates

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 2772ff9..8985c72 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -446,10 +446,9 @@ extension BotGatewayManager {
             guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
             Task {
                 let (code, codeDesc) = self.getCloseCodeAndDescription(of: ws)
+                let isDebugLevelCode = [.goingAway, nil, .unexpectedServerError].contains(code)
                 self.logger.log(
-                    /// If its `nil` or `.goingAway`, then it's likely just a resume notice.
-                    /// Otherwise it might be an error.
-                    level: (code == nil || code == .goingAway) ? .debug : .error,
+                    level: isDebugLevelCode ? .debug : .warning,
                     "Received connection close notification. Will try to reconnect",
                     metadata: [
                         "code": .string(codeDesc),

commit ebaaab58a33840fe88d79cc9109b0ab24b970992
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Wed Jan 25 17:30:56 2023 +0330

    fully support webhook endpoints

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
index 6f63138..2772ff9 100644
--- a/Sources/DiscordGateway/BotGatewayManager.swift
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -321,7 +321,7 @@ extension BotGatewayManager {
             self.sessionId = payload.session_id
             self.resumeGatewayURL = payload.resume_gateway_url
         case .resumed:
-            logger.notice("Received resume notice. The connection is fully established", metadata: [
+            logger.debug("Received resume notice. The connection is fully established", metadata: [
                 "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
             ])
             await self.onSuccessfulConnection()
@@ -449,7 +449,7 @@ extension BotGatewayManager {
                 self.logger.log(
                     /// If its `nil` or `.goingAway`, then it's likely just a resume notice.
                     /// Otherwise it might be an error.
-                    level: (code == nil || code == .goingAway) ? .notice : .error,
+                    level: (code == nil || code == .goingAway) ? .debug : .error,
                     "Received connection close notification. Will try to reconnect",
                     metadata: [
                         "code": .string(codeDesc),

commit 1e2e79e6e0f4c99bd558809c9b033beabd3c877d
Author: Mahdi Bahrami <github@mahdibm.com>
Date:   Tue Jan 24 05:12:35 2023 +0330

    Add Discord Logger (#25)

diff --git a/Sources/DiscordGateway/BotGatewayManager.swift b/Sources/DiscordGateway/BotGatewayManager.swift
new file mode 100644
index 0000000..6f63138
--- /dev/null
+++ b/Sources/DiscordGateway/BotGatewayManager.swift
@@ -0,0 +1,643 @@
+import Foundation
+import WebSocketKitFork
+import AsyncHTTPClient
+import Atomics
+import Logging
+import enum NIOWebSocket.WebSocketErrorCode
+import struct NIOCore.TimeAmount
+
+public actor BotGatewayManager: GatewayManager {
+    
+    private weak var ws: WebSocket?
+    let eventLoopGroup: any EventLoopGroup
+    /// A client to send requests to Discord.
+    public nonisolated let client: any DiscordClient
+    /// Max frame size we accept to receive through the websocket connection.
+    nonisolated let maxFrameSize: Int
+    /// Generator of `BotGatewayManager` ids.
+    static let idGenerator = ManagedAtomic(0)
+    /// This gateway manager's identifier.
+    public nonisolated let id = BotGatewayManager.idGenerator
+        .wrappingIncrementThenLoad(ordering: .relaxed)
+    let logger: Logger
+    
+    //MARK: Event hooks
+    var onEvents: [(Gateway.Event) -> ()] = []
+    var onEventParseFailures: [(Error, ByteBuffer) -> ()] = []
+    
+    //MARK: Connection data
+    nonisolated let identifyPayload: Gateway.Identify
+    
+    //MARK: Connection state
+    nonisolated let _state = ManagedAtomic(GatewayState.noConnection)
+    /// The current state of the gateway manager.
+    public nonisolated var state: GatewayState {
+        self._state.load(ordering: .relaxed)
+    }
+    
+    //MARK: Send queue
+    
+    /// 120 per 60 seconds (1 every 500ms),
+    /// per https://discord.com/developers/docs/topics/gateway#rate-limiting
+    var sendQueue = SerialQueue(waitTime: .milliseconds(500))
+    
+    //MARK: Current connection properties
+    
+    /// An ID to keep track of connection changes.
+    nonisolated let connectionId = ManagedAtomic(UInt(0))
+    
+    //MARK: Resume-related current-connection properties
+    
+    /// The sequence number for the payloads sent to us.
+    var sequenceNumber: Int? = nil
+    /// The ID of the current Discord-related session.
+    var sessionId: String? = nil
+    /// Gateway URL for resuming the connection, so we don't need to make an api call.
+    var resumeGatewayURL: String? = nil
+    
+    //MARK: Shard-ing
+    var maxConcurrency: Int? = nil
+    var isFirstConnection = true
+    
+    //MARK: Compression
+    let compression: Bool
+    
+    //MARK: Backoff
+    
+    /// Discord cares about the identify payload for rate-limiting and if we send
+    /// more than 1000 identifies in a day, Discord will revoke the bot token.
+    /// This Backoff does not necessarily prevent your bot token getting revoked,
+    /// but in the worst case, doesn't let it happen sooner than ~8 hours.
+    /// This also helps in other situations, for example when there is a Discord outage.
+    let connectionBackoff = Backoff(
+        base: 2,
+        maxExponentiation: 7,
+        coefficient: 1,
+        minBackoff: 15
+    )
+    
+    //MARK: Ping-pong tracking properties
+    var unsuccessfulPingsCount = 0
+    var lastPongDate = Date()
+    
+    /// - Parameters:
+    ///   - eventLoopGroup: An `EventLoopGroup`.
+    ///   - httpClient: A `HTTPClient`.
+    ///   - client: A `DiscordClient` to use.
+    ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
+    ///   - compression: Enables transport compression for less network bandwidth usage
+    ///    but more CPU load.
+    ///   - appId: Your Discord application id.
+    ///   - identifyPayload: The identification payload that is sent to Discord.
+    public init(
+        eventLoopGroup: EventLoopGroup,
+        httpClient: HTTPClient,
+        client: any DiscordClient,
+        maxFrameSize: Int =  1 << 31,
+        compression: Bool = false,
+        appId: String? = nil,
+        identifyPayload: Gateway.Identify
+    ) {
+        self.eventLoopGroup = eventLoopGroup
+        self.client = client
+        self.maxFrameSize = maxFrameSize
+        self.compression = compression
+        self.identifyPayload = identifyPayload
+        var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
+        logger[metadataKey: "gateway-id"] = .string("\(self.id)")
+        self.logger = logger
+    }
+    
+    /// - Parameters:
+    ///   - eventLoopGroup: An `EventLoopGroup`.
+    ///   - httpClient: A `HTTPClient`.
+    ///   - clientConfiguration: Configuration of the `DiscordClient`.
+    ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
+    ///   - compression: Enables transport compression for less network bandwidth usage
+    ///    but more CPU load.
+    ///   - appId: Your Discord application id.
+    ///   - identifyPayload: The identification payload that is sent to Discord.
+    public init(
+        eventLoopGroup: EventLoopGroup,
+        httpClient: HTTPClient,
+        clientConfiguration: ClientConfiguration = .init(),
+        maxFrameSize: Int =  1 << 31,
+        compression: Bool = false,
+        appId: String? = nil,
+        identifyPayload: Gateway.Identify
+    ) {
+        self.eventLoopGroup = eventLoopGroup
+        self.client = DefaultDiscordClient(
+            httpClient: httpClient,
+            token: identifyPayload.token,
+            appId: appId,
+            configuration: clientConfiguration
+        )
+        self.maxFrameSize = maxFrameSize
+        self.compression = compression
+        self.identifyPayload = identifyPayload
+        var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
+        logger[metadataKey: "gateway-id"] = .string("\(self.id)")
+        self.logger = logger
+    }
+    
+    /// - Parameters:
+    ///   - eventLoopGroup: An `EventLoopGroup`.
+    ///   - httpClient: A `HTTPClient`.
+    ///   - clientConfiguration: Configuration of the `DiscordClient`.
+    ///   - maxFrameSize: Max frame size the WebSocket should allow receiving.
+    ///   - compression: Enables transport compression for less network bandwidth usage
+    ///    but more CPU load.
+    ///   - token: Your Discord bot-token.
+    ///   - appId: Your Discord application id.
+    ///   - shard: What shard this Manager is representing, incase you use shard-ing at all.
+    ///   - presence: The initial presence of the bot.
+    ///   - intents: The Discord intents you want to receive messages for.
+    public init(
+        eventLoopGroup: EventLoopGroup,
+        httpClient: HTTPClient,
+        clientConfiguration: ClientConfiguration = .init(),
+        maxFrameSize: Int =  1 << 31,
+        compression: Bool = false,
+        token: String,
+        appId: String? = nil,
+        shard: IntPair? = nil,
+        presence: Gateway.Identify.Presence? = nil,
+        intents: [Gateway.Intent] = []
+    ) {
+        let token = Secret(token)
+        self.eventLoopGroup = eventLoopGroup
+        self.client = DefaultDiscordClient(
+            httpClient: httpClient,
+            token: token,
+            appId: appId,
+            configuration: clientConfiguration
+        )
+        self.maxFrameSize = maxFrameSize
+        self.compression = compression
+        self.identifyPayload = .init(
+            token: token,
+            shard: shard,
+            presence: presence,
+            intents: intents
+        )
+        var logger = DiscordGlobalConfiguration.makeLogger("GatewayManager")
+        logger[metadataKey: "gateway-id"] = .string("\(self.id)")
+        self.logger = logger
+    }
+    
+    /// Starts connecting to Discord.
+    /// `_state` must be set to an appropriate value before triggering this function.
+    public func connect() async {
+        logger.debug("Connect method triggered")
+        /// Guard we're attempting to connect too fast
+        if let connectIn = await connectionBackoff.canPerformIn() {
+            logger.warning("Cannot try to connect immediately due to backoff", metadata: [
+                "wait-milliseconds": .stringConvertible(connectIn.nanoseconds / 1_000_000)
+            ])
+            await self.sleep(for: connectIn)
+        }
+        /// Guard if other connections are in process
+        guard [.noConnection, .configured, .stopped].contains(self.state) else {
+            logger.error("Gateway state doesn't allow a new connection", metadata: [
+                "state": .stringConvertible(state)
+            ])
+            return
+        }
+        self._state.store(.connecting, ordering: .relaxed)
+        await self.sendQueue.reset()
+        let gatewayURL = await getGatewayURL()
+        var urlSuffix = "?v=\(DiscordGlobalConfiguration.apiVersion)&encoding=json"
+        logger.trace("Will wait for other shards if needed")
+        await waitInShardQueueIfNeeded()
+        var configuration = WebSocketClient.Configuration(maxFrameSize: self.maxFrameSize)
+        if compression {
+            urlSuffix += "&compress=zlib-stream"
+            configuration.decompression = .enabled
+        }
+        logger.trace("Will try to connect to Discord through web-socket")
+        WebSocket.connect(
+            to: gatewayURL + urlSuffix,
+            configuration: configuration,
+            on: eventLoopGroup
+        ) { ws in
+            self.logger.debug("Connected to Discord through web-socket. Will configure")
+            self.closeWebSocket(ws: self.ws)
+            self.ws = ws
+            self.configureWebSocket()
+        }.whenFailure { [self] error in
+            logger.error("WebSocket error while connecting to Discord", metadata: [
+                "error": "\(error)"
+            ])
+            self._state.store(.noConnection, ordering: .relaxed)
+            Task { await self.connect() }
+        }
+    }
+    
+    /// Requests guild members from Discord.
+    /// Refer to the documentation link of ``Gateway.RequestGuildMembers`` for more info.
+    public func requestGuildMembersChunk(payload: Gateway.RequestGuildMembers) {
+        /// This took a lot of time to figure out, not sure why it needs opcode `1`.
+        self.send(payload: .init(
+            opcode: .requestGuildMembers,
+            data: .requestGuildMembers(payload)
+        ), opcode: 1)
+    }
+    
+    /// Adds a handler to be notified of events.
+    public func addEventHandler(_ handler: @escaping (Gateway.Event) -> Void) {
+        self.onEvents.append(handler)
+    }
+    
+    /// Adds a handler to be notified of event parsing failures.
+    public func addEventParseFailureHandler(_ handler: @escaping (Error, ByteBuffer) -> Void) {
+        self.onEventParseFailures.append(handler)
+    }
+    
+    /// Disconnects from Discord.
+    public func disconnect() async {
+        logger.debug("Will disconnect", metadata: [
+            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+        ])
+        self.connectionId.wrappingIncrement(ordering: .relaxed)
+        await connectionBackoff.resetTryCount()
+        self.closeWebSocket(ws: self.ws)
+        self._state.store(.stopped, ordering: .relaxed)
+        self.isFirstConnection = true
+        await self.sendQueue.reset()
+    }
+}
+
+extension BotGatewayManager {
+    private func configureWebSocket() {
+        let connId = self.connectionId.wrappingIncrementThenLoad(ordering: .relaxed)
+        self.setupOnText(forConnectionWithId: connId)
+        self.setupOnClose(forConnectionWithId: connId)
+        self._state.store(.configured, ordering: .relaxed)
+    }
+    
+    private func processEvent(_ event: Gateway.Event) async {
+        if let sequenceNumber = event.sequenceNumber {
+            self.sequenceNumber = sequenceNumber
+        }
+        
+        switch event.opcode {
+        case .heartbeat:
+            self.sendPing(forConnectionWithId: self.connectionId.load(ordering: .relaxed))
+        case .heartbeatAccepted:
+            self.lastPongDate = Date()
+        case .reconnect:
+            logger.debug("Received reconnect request. Will reconnect after connection closure")
+        default:
+            break
+        }
+        
+        switch event.data {
+        case let .invalidSession(canResume):
+            logger.warning("Got invalid session. Will try to reconnect", metadata: [
+                "canResume": .stringConvertible(canResume)
+            ])
+            if !canResume {
+                self.sequenceNumber = nil
+                self.resumeGatewayURL = nil
+                self.sessionId = nil
+            }
+            self._state.store(.noConnection, ordering: .relaxed)
+            await self.connect()
+        case let .hello(hello):
+            logger.debug("Received 'hello'")
+            /// Disable websocket-kit automatic pings
+            self.ws?.pingInterval = nil
+            self.setupPingTask(
+                forConnectionWithId: self.connectionId.load(ordering: .relaxed),
+                every: .milliseconds(Int64(hello.heartbeat_interval))
+            )
+            await self.sendResumeOrIdentify()
+        case let .ready(payload):
+            logger.notice("Received ready notice. The connection is fully established", metadata: [
+                "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+            ])
+            await self.onSuccessfulConnection()
+            self.sessionId = payload.session_id
+            self.resumeGatewayURL = payload.resume_gateway_url
+        case .resumed:
+            logger.notice("Received resume notice. The connection is fully established", metadata: [
+                "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+            ])
+            await self.onSuccessfulConnection()
+        default:
+            break
+        }
+    }
+    
+    private func getGatewayURL() async -> String {
+        logger.debug("Will try to get Discord gateway url")
+        if self.sequenceNumber != nil, /// If can resume at all
+           let gatewayURL = self.resumeGatewayURL {
+            logger.trace("Got Discord gateway url from `resumeGatewayURL`")
+            return gatewayURL
+        } else {
+            /// If the bot is using shard-ing, we need to call a different endpoint
+            /// to get some more info than only the gateway url.
+            if identifyPayload.shard == nil {
+                if let gatewayURL = try? await client.getGateway().decode().url {
+                    logger.trace("Got Discord gateway url from gateway api call")
+                    return gatewayURL
+                }
+            } else {
+                if let gatewayBot = try? await client.getGatewayBot().decode() {
+                    logger.trace("Got Discord gateway url from gateway-bot api call. Max concurrency: \(gatewayBot.session_start_limit.max_concurrency)")
+                    self.maxConcurrency = gatewayBot.session_start_limit.max_concurrency
+                    return gatewayBot.url
+                }
+            }
+            logger.error("Cannot get gateway url to connect to. Will retry in 10 seconds")
+            await self.sleep(for: .seconds(10))
+            return await self.getGatewayURL()
+        }
+    }
+    
+    private func sendResumeOrIdentify() async {
+        if let sessionId = self.sessionId,
+           let lastSequenceNumber = self.sequenceNumber {
+            self.sendResume(sessionId: sessionId, sequenceNumber: lastSequenceNumber)
+        } else {
+            logger.debug("Can't resume last Discord connection. Will identify", metadata: [
+                "sessionId_length": .stringConvertible(self.sessionId?.count ?? -1),
+                "lastSequenceNumber": .stringConvertible(self.sequenceNumber ?? -1)
+            ])
+            await self.sendIdentify()
+        }
+    }
+    
+    private func sendResume(sessionId: String, sequenceNumber: Int) {
+        let resume = Gateway.Event(
+            opcode: .resume,
+            data: .resume(.init(
+                token: identifyPayload.token,
+                session_id: sessionId,
+                sequence: sequenceNumber
+            ))
+        )
+        self.send(
+            payload: resume,
+            opcode: Gateway.Opcode.identify.rawValue
+        )
+        
+        /// Invalidate `sequenceNumber` info for the next connection, incase this one fails.
+        /// This will be a notice for the next connection to
+        /// not try resuming anymore, if this connection has failed.
+        self.sequenceNumber = nil
+        
+        logger.debug("Sent resume request to Discord")
+    }
+    
+    private func sendIdentify() async {
+        await connectionBackoff.willTry()
+        let identify = Gateway.Event(
+            opcode: .identify,
+            data: .identify(identifyPayload)
+        )
+        self.send(payload: identify)
+    }
+    
+    private func setupOnText(forConnectionWithId connectionId: UInt) {
+        if compression {
+            self.ws?.onBinary { _, buffer in
+                self.processBinaryData(buffer, forConnectionWithId: connectionId)
+            }
+        } else {
+            self.ws?.onTextBuffer { _, buffer in
+                self.processBinaryData(buffer, forConnectionWithId: connectionId)
+            }
+        }
+    }
+    
+    private func processBinaryData(_ buffer: ByteBuffer, forConnectionWithId connectionId: UInt) {
+        self.logger.debug("Got text from websocket \(String(buffer: buffer))")
+        guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
+        let data = Data(buffer: buffer)
+        do {
+            let event = try DiscordGlobalConfiguration.decoder.decode(
+                Gateway.Event.self,
+                from: data
+            )
+            self.logger.debug("Decoded event: \(event)")
+            Task { await self.processEvent(event) }
+            for onEvent in self.onEvents {
+                onEvent(event)
+            }
+        } catch {
+            self.logger.debug("Failed to decode event. Error: \(error)")
+            for onEventParseFailure in self.onEventParseFailures {
+                onEventParseFailure(error, buffer)
+            }
+        }
+    }
+    
+    private func setupOnClose(forConnectionWithId connectionId: UInt) {
+        guard let ws = self.ws else {
+            logger.error("Cannot setup web-socket on-close because there are no active web-sockets. This is an issue in the library, please report: https://github.com/MahdiBM/DiscordBM/issues")
+            return
+        }
+        ws.onClose.whenComplete { [weak self] _ in
+            guard let `self` = self else { return }
+            self.logger.debug("Received connection close notification for a web-socket")
+            guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
+            Task {
+                let (code, codeDesc) = self.getCloseCodeAndDescription(of: ws)
+                self.logger.log(
+                    /// If its `nil` or `.goingAway`, then it's likely just a resume notice.
+                    /// Otherwise it might be an error.
+                    level: (code == nil || code == .goingAway) ? .notice : .error,
+                    "Received connection close notification. Will try to reconnect",
+                    metadata: [
+                        "code": .string(codeDesc),
+                        "closedConnectionId": .stringConvertible(
+                            self.connectionId.load(ordering: .relaxed)
+                        )
+                    ]
+                )
+                if self.canTryReconnect(code: ws.closeCode) {
+                    self._state.store(.noConnection, ordering: .relaxed)
+                    await self.connect()
+                } else {
+                    self._state.store(.stopped, ordering: .relaxed)
+                    self.connectionId.wrappingIncrement(ordering: .relaxed)
+                    self.logger.critical("Will not reconnect because Discord does not allow it. Something is wrong. Your close code is '\(codeDesc)', check Discord docs at https://discord.com/developers/docs/topics/opcodes-and-status-codes#gateway-gateway-close-event-codes and see what it means. Report at https://github.com/MahdiBM/DiscordBM/issues if you think this is a library issue")
+                }
+            }
+        }
+    }
+    
+    private nonisolated  func getCloseCodeAndDescription(
+        of ws: WebSocket
+    ) -> (WebSocketErrorCode?, String) {
+        let code = ws.closeCode
+        let description: String
+        switch code {
+        case let .unknown(codeNumber):
+            switch Gateway.CloseCode(rawValue: codeNumber) {
+            case let .some(discordCode):
+                description = "\(discordCode)"
+            case .none:
+                description = "\(codeNumber)"
+            }
+        case let .some(anyOtherCode):
+            description = "\(anyOtherCode)"
+        case .none:
+            description = "nil"
+        }
+        return (code, description)
+    }
+    
+    private nonisolated func canTryReconnect(code: WebSocketErrorCode?) -> Bool {
+        switch code {
+        case let .unknown(codeNumber):
+            guard let discordCode = Gateway.CloseCode(rawValue: codeNumber) else { return true }
+            return discordCode.canTryReconnect
+        default: return true
+        }
+    }
+    
+    private func setupPingTask(
+        forConnectionWithId connectionId: UInt,
+        every interval: TimeAmount
+    ) {
+        Task {
+            await self.sleep(for: interval)
+            guard self.connectionId.load(ordering: .relaxed) == connectionId else {
+                self.logger.trace("Canceled a ping task with connection id: \(connectionId)")
+                return /// cancel
+            }
+            self.logger.debug("Will send automatic ping for connection id: \(connectionId)")
+            self.sendPing(forConnectionWithId: connectionId)
+            self.setupPingTask(forConnectionWithId: connectionId, every: interval)
+        }
+    }
+    
+    private func sendPing(forConnectionWithId connectionId: UInt) {
+        logger.trace("Will ping for connection id \(connectionId)")
+        self.send(payload: .init(
+            opcode: .heartbeat,
+            data: .heartbeat(lastSequenceNumber: self.sequenceNumber)
+        ))
+        Task {
+            await self.sleep(for: .seconds(10))
+            guard self.connectionId.load(ordering: .relaxed) == connectionId else { return }
+            /// 15 == 10 + 5. 10 seconds that we slept, + 5 seconds tolerance.
+            /// The tolerance being too long should not matter as pings usually happen
+            /// only once in ~45 seconds, and a successful ping will reset the counter anyway.
+            if self.lastPongDate.addingTimeInterval(15) > Date() {
+                logger.trace("Successful ping")
+                self.unsuccessfulPingsCount = 0
+            } else {
+                logger.trace("Unsuccessful ping")
+                self.unsuccessfulPingsCount += 1
+            }
+            if unsuccessfulPingsCount > 2 {
+                logger.debug("Too many unsuccessful pings. Will try to reconnect", metadata: [
+                    "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                ])
+                self._state.store(.noConnection, ordering: .relaxed)
+                await self.connect()
+            }
+        }
+    }
+    
+    private func send(
+        payload: Gateway.Event,
+        opcode: UInt8? = nil,
+        connectionId: UInt? = nil,
+        tryCount: Int = 0
+    ) {
+        self.sendQueue.perform { [self] in
+            Task {
+                if let connectionId = connectionId,
+                   self.connectionId.load(ordering: .relaxed) != connectionId {
+                    return
+                }
+                
+                let opcode = opcode ?? payload.opcode.rawValue
+                
+                let data: Data
+                do {
+                    data = try DiscordGlobalConfiguration.encoder.encode(payload)
+                } catch {
+                    logger.error("Could not encode payload. This is a library issue, please report on https://github.com/MahdiBM/DiscordBM/issues", metadata: [
+                        "payload": .string("\(payload)"),
+                        "opcode": .stringConvertible(opcode),
+                        "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                    ])
+                    return
+                }
+                
+                if let ws = await self.ws {
+                    do {
+                        try await ws.send(
+                            raw: data,
+                            opcode: .init(encodedWebSocketOpcode: opcode)!
+                        )
+                    } catch {
+                        logger.error("Could not send payload through websocket", metadata: [
+                            "error": "\(error)",
+                            "payload": .string("\(payload)"),
+                            "opcode": .stringConvertible(opcode),
+                            "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                        ])
+                    }
+                } else {
+                    logger.warning("Trying to send through ws when a connection is not established", metadata: [
+                        "payload": .string("\(payload)"),
+                        "state": .stringConvertible(self._state.load(ordering: .relaxed)),
+                        "connectionId": .stringConvertible(self.connectionId.load(ordering: .relaxed))
+                    ])
+                }
+            }
+        }
+    }
+    
+    private func onSuccessfulConnection() async {
+        self._state.store(.connected, ordering: .relaxed)
+        await connectionBackoff.resetTryCount()
+        self.unsuccessfulPingsCount = 0
+        await self.sendQueue.reset()
+    }
+    
+    private func waitInShardQueueIfNeeded() async {
+        if isFirstConnection,
+           let shard = identifyPayload.shard,
+           let maxConcurrency = maxConcurrency {
+            isFirstConnection = false
+            let bucketIndex = shard.first / maxConcurrency
+            if bucketIndex > 0 {
+                /// Wait 2 seconds for each bucket index.
+                /// These 2 seconds is nothing scientific.
+                /// Optimally we should implement managing all shards of a bot together
+                /// so we can know when shards connect and can start the new bucket, but
+                /// that doesn't seem easy as shards might be running outside only 1
+                /// process and we won't be able to manage them easily.
+                await self.sleep(for: .seconds(Int64(bucketIndex) * 2))
+            }
+        }
+    }
+    
+    private nonisolated func closeWebSocket(ws: WebSocket?) {
+        logger.debug("Will possibly close a web-socket")
+        ws?.close().whenFailure {
+            self.logger.warning("Connection close error", metadata: [
+                "error": "\($0)"
+            ])
+        }
+    }
+    
+    private func sleep(for time: TimeAmount) async {
+        do {
+            try await Task.sleep(nanoseconds: UInt64(time.nanoseconds))
+        } catch {
+            logger.warning("Task failed to sleep properly", metadata: [
+                "error": "\(error)"
+            ])
+        }
+    }
+}
